#!/usr/bin/env bash

######## CONSTANTS ########

readonly script_name='sb'
readonly version='1.0.0'
readonly config_filename=".${script_name}config.json"
readonly config_filepath=~/$config_filename

readonly fm_red="$(tput setaf 1)"
readonly fm_green="$(tput setaf 2)"
readonly fm_yellow="$(tput setaf 3)"
readonly fm_magenta="$(tput setaf 5)"
readonly fm_cyan="$(tput setaf 6)"
readonly fm_bold="$(tput bold)"
readonly fm_underline="$(tput smul)"
readonly fm_reset="$(tput sgr0)"

readonly style_command_title='cmd'
readonly style_error='err'

readonly virtual_env_type_py='py'
readonly virtual_env_type_node='node'

readonly project_type_django='django'
readonly project_type_node='node'

readonly command_build='build'
readonly command_freeze='freeze'
readonly command_restore='restore'
readonly command_run='run'
readonly command_check='check'
readonly command_print_config='print-config'
readonly command_reset='reset'
readonly command_scipt_run='script-run'
readonly commands=(
	"$command_build"
	"$command_freeze"
	"$command_restore"
	"$command_run"
	"$command_check"
	"$command_scipt_run"
	"$command_print_config"
	"$command_reset"
)

readonly option_help='--help'
readonly option_help_short='-h'
readonly option_version='--version'
readonly option_verbose='--verbose'
readonly option_verbose_short='-v'
readonly allowed_options_base=(
	"$option_help"
	"$option_help_short"
	"$option_verbose"
	"$option_verbose_short"
	"$option_version"
)

readonly option_branch='--branch'
readonly option_branch_short='-b'
readonly option_delete='--delete'
readonly option_delete_short='-d'
readonly freeze_command_allowed_options=( "$option_branch" "$option_branch_short" )
readonly restore_command_allowed_options=( "$option_delete" "$option_delete_short" )
readonly run_command_allowed_options=( "$option_branch" "$option_branch_short" )

readonly freeze_command_default_branch='master'

readonly message_usage="usage: $script_name [$option_help|$option_help_short] [$option_version] [$option_verbose|$option_verbose_short] <command> [<args>]"
readonly message_usage_help="$message_usage

There are a number of possible commands:

	${fm_yellow}$command_build		${fm_cyan}$script_name $command_build [--<project_short_name>|-<proj_cli_char> <project-branch>...]${fm_reset}
			Builds each specified project and its dependant services with the specified
			branches. Possible projects depend on your config file

	${fm_yellow}$command_freeze		${fm_cyan}$script_name $command_freeze <project> [$option_branch|$option_branch_short <branch>]${fm_reset}
			Freeze database for project. Uses the master branch by default

	${fm_yellow}$command_restore		${fm_cyan}$script_name $command_restore <project> [$option_delete|$option_delete_short]${fm_reset}
			Restores project database to last time the freeze command was run. Optionally
			removes clean database after successful restore

	${fm_yellow}$command_run		${fm_cyan}$script_name $command_run <project> [$option_branch|$option_branch_short <branch>] <command> [<args>]${fm_reset}
			Loads project environment and runs required command in it

	${fm_yellow}$command_check		${fm_cyan}$script_name $command_check${fm_reset}
			Checks to ensure all required environment variables are set up and script is
			accessible on your path

	${fm_yellow}$command_reset		${fm_cyan}$script_name $command_reset${fm_reset}
			Removes tmux sessions and unlocks waiting windows

	${fm_yellow}$command_print_config	${fm_cyan}$script_name $command_print_config${fm_reset}
			Prints out the config file found at $config_filepath. All commands
			depend on this file being accessible
"
readonly message_config_file_not_readable="The config file '$config_filepath' does not exist or is not readable"
readonly message_check='Running environment check...'
readonly message_verbose='Verbose mode switched on'
readonly message_not_enough_args='Not enough arguments passed'
readonly message_unknown_arg='Unknown argument'
readonly message_incorrect_num_of_args='Incorrect number of arguments passed'
readonly message_unknown_project='Unknown project'
readonly message_command_does_not_support_project='This command does not support the project'
readonly message_db_does_not_exist='Database does not exist'
readonly message_multiple_running_tmux_sessions='Multiple running tmux sessions'
readonly message_function_returned_error='Function returned non-zero value'

readonly clean_db_suffix='clean'
readonly tmux_default_lock_channel='lock'
readonly tmux_window_name_default='default'
readonly tmux_window_name_worker='worker'
readonly tmux_win_name_django_suffix='_django'
readonly tmux_win_name_celery_suffix='_celery'
readonly tmux_win_name_npm_watch_suffix='_npm_w'
readonly sesh_name_sep=';'

readonly tmux_update_type_create='create'
readonly tmux_update_type_delete='delete'
readonly tmux_update_type_kill_sig='killsig'
readonly tmux_update_type_set_env_var='setenvv'

readonly file_pattern_py_requirments='*requirements*'
readonly file_pattern_node_requirements='*package.json*'
readonly file_pattern_django_migrations='*migrations*'
readonly file_pattern_ts_templates='*fixtures/termsheet_templates*'


######## CONFIG VARIABLES  ########

declare -a projects
declare -a project_indices
declare -a project_names
declare -a project_short_names
declare -a project_chars
declare -a project_dirs
declare -a project_virtual_env_types
declare -a project_virtual_env_names
declare -a project_ports
declare -a project_requires_load_termsheet_templates
declare -a project_celery_app_names
declare -a project_db_names
declare -a dependant_project_indices
declare -a independant_project_indices
declare -a projects_with_url_env_var_indices
declare -a project_url_env_var_names
declare -a project_url_local
declare -a project_url_default
declare -a tracked_projects
declare -a git_independent_projects
declare -a project_tracked_by
declare -a env_vars_required


######## GLOBAL VARIABLES ########

verbose_mode='false'


######## CONFIG MANAGEMENT ########

function load_config() {
	if [[ ! -r "$config_filepath" ]]; then
		print_format "$style_error" "$message_config_file_not_readable"
		return 1
	fi

	local config_json_content="$(<"$config_filepath")"
	# validate_config "$config_json_content"

	# Parse config file from memory
	local config_projects_content="$(echo $config_json_content | jq ".projects")"
	local num_of_projects="$(echo $config_projects_content | jq "length")"

	# Load required config parameters for each project
	for ((i=0; i<$num_of_projects; i++)); do
		local config_project_content="$(echo $config_projects_content | jq ".[$i]")"
		local project_name="$(echo $config_project_content | jq -r ".name")"
		local project_short_name="$(echo $config_project_content | jq -r ".shortName")"
		local project_cli_char="$(echo $config_project_content | jq -r ".cliChar")"
		local project_type="$(echo $config_project_content | jq -r ".type")"
		local project_is_dependant="$(echo $config_project_content | jq -r ".dependant")"
		local project_track_project="$(echo $config_project_content | jq -r 'has("tracksProject")')"
		local project_env_variables="$(echo $config_project_content | jq -r ".environmentVariables")"
		local project_has_url="$(echo $project_env_variables | jq -r 'has("url")')"
		local project_dir_env_var="$(echo $project_env_variables | jq -r ".rootDir")"
		local project_env_name_env_var="$(echo $project_env_variables | jq -r ".envName")"
		local project_dir="${!project_dir_env_var}"
		local project_env_name="${!project_env_name_env_var}"

		local project_index_varname="$(get_project_index_varname "${project_short_name}")"
		local project_index_varname_long="$(get_project_index_varname "${project_name}")"
		local project_index_varname_char="$(get_project_index_varname "${project_cli_char}")"

		# Not ideal but seemingly the only way to declare a global variable in a function when the name
		# of that variable is stored in another variable. Otherwise I can simply use name=value syntax
		export ${project_index_varname}="$i"
		export ${project_index_varname_long}="$i"
		export ${project_index_varname_char}="$i"
		local project_index="${!project_index_varname}"

		projects+=("$project_name" "$project_short_name")
		project_indices+=("$project_index")
		project_names[$project_index]="$project_name"
		project_short_names[$project_index]="$project_short_name"
		project_chars[$project_index]="$project_cli_char"
		project_types[$project_index]="$project_type"
		project_dirs[$project_index]="$project_dir"
		project_virtual_env_names[$project_index]="$project_env_name"

		for evk in $(echo $config_project_content | jq -r ".environmentVariables | keys[]"); do
			env_vars_required+=("$(echo $project_env_variables | jq -r ".$evk")")
		done

		if [[ "$project_is_dependant" = 'true' ]]; then
			dependant_project_indices+=("${project_index}")
		else
			independant_project_indices+=("${project_index}")
		fi

		if [[ "$project_has_url" = 'true' ]]; then
			# TODO: Implement arbitrary url names
			local url_env_var_name="$(echo $project_env_variables | jq -r ".url")"
			local url_local="$(echo $config_project_content | jq -r ".urls.local")"
			local url_default="$(echo $config_project_content | jq -r ".urls.default")"

			projects_with_url_env_var_indices+=("$project_index")
			project_url_env_var_names["$project_index"]="$url_env_var_name"
			project_url_local["$project_index"]="$url_local"
			project_url_default["$project_index"]="$url_default"
		fi

		if [[ "$project_track_project" = 'true' ]]; then
			local tracked_project="$(echo $config_project_content | jq -r ".tracksProject")"
			local tracked_project_i="$(get_project_index "$tracked_project")"

			tracked_projects+=("$tracked_project_i")
			project_tracked_by["$tracked_project_i"]="$project_index"

		else
			git_independent_projects+=("$project_index")
		fi

		case "$project_type" in
			"$project_type_django")
				local project_port="$(echo $config_project_content | jq -r ".port")"
				local has_celery_app="$(echo $config_project_content | jq -r 'has("celeryAppName")')"
				local has_load_termsheet_templates="$(echo $config_project_content | jq -r 'has("loadTermsheetTemplates")')"
				local project_db_name_env_var="$(echo $project_env_variables | jq -r ".dbName")"
				local project_db_name="${!project_db_name_env_var}"

				project_virtual_env_types[$project_index]="$virtual_env_type_py"
				project_ports[$project_index]="$project_port"
				project_db_names[$project_index]="$project_db_name"

				if [[ "$has_celery_app" = 'true' ]]; then
					local project_celery_app_name="$(echo $config_project_content | jq -r ".celeryAppName")"
					project_celery_app_names[$project_index]="$project_celery_app_name"
				fi

				if [[ "$has_load_termsheet_templates" = 'true' ]]; then
					project_requires_load_termsheet_templates[$project_index]='true'
				else
					project_requires_load_termsheet_templates[$project_index]='false'
				fi
				;;

			"$project_type_node")
				project_virtual_env_types[$project_index]="$virtual_env_type_node"
				;;
		esac
	done

	return 0
}

function validate_config() {
	print_format "$style_error" "Not implemented"
}


######## MAPPING FUNCTIONS ########

function get_project_index_varname() {
	local project="$1"
	printf "proj_i_$project"
}

function get_project_index() {
	local project="$1"
	local project_index_varname="$(get_project_index_varname "$project")"

	if [[ -z "${!project_index_varname}" ]]; then
		return 1
	fi

	printf "${!project_index_varname}"
	return 0
}

function get_project_from_option() {
	local option="$1"

	if [[ "$option" =~ ^--[a-z].+$ ]]; then
		project_short_name="${option:2}"
		printf "$project_short_name"

	elif [[ "$option" =~ ^-[a-z]$ ]]; then
		project_char="${option:1}"
		printf "$project_char"

	else
		return 1
	fi

	return 0
}


######## UTILITY FUNCTIONS ########

function is_in_array() {
	local search="$1"
	local arr=("${@:2}")

	for val in "${arr[@]}"; do
		if [[ "$search" = "$val" ]]; then
			return 0
		fi
	done

	return 1
}

function is_valid_base_option() {
	local search="$1"
	is_in_array "$search" "${allowed_options_base[@]}"
}

function is_valid_command() {
	local search="$1"
	is_in_array "$search" "${commands[@]}"
}

function is_valid_project() {
	local search="$1"
	is_in_array "$search" "${projects[@]}"
}

function is_valid_project_for_freeze_command() {
	local project="$1"
	local -i project_i
	project_i=$(get_project_index "$project") || return 1
	is_in_array "$project_i" "${!project_db_names[@]}"
}

function is_valid_project_tag_for_build_command() {
	local search="$1"
	is_in_array "$search" "${build_command_project_tags[@]}"
}

function is_valid_run_command_option() {
	local search="$1"
	is_in_array "$search" "${run_command_allowed_options[@]}"
}

function is_valid_freeze_command_option() {
	local search="$1"
	is_in_array "$search" "${freeze_command_allowed_options[@]}"
}

function is_valid_restore_command_option() {
	local search="$1"
	is_in_array "$search" "${restore_command_allowed_options[@]}"
}

function is_valid_build_command_project() {
	local project="$1"
	local -i project_i

	project_i=$(get_project_index "$project") || return 1

	is_in_array "$project_i" "${git_independent_projects[@]}" \
	  && is_in_array "$project_i" "${project_indices[@]}"
}

function is_valid_build_command_option() {
	local option="$1"
	local project="$(get_project_from_option "$option")"
	is_valid_build_command_project "$project"
}

function print_format() {
	local type="$1"
	local msg="$2"

	case "$type" in
		"$style_command_title")
			printf "\n%s\n" "${fm_yellow}${fm_bold}TASK:${fm_reset} ${fm_bold}${msg}${fm_reset}"
			printf "%s\n" "--------------------------------------------------------------"
			;;
		"$style_error")
			printf "${fm_red}ERR!${fm_reset} $msg\n" 1>&2
			;;
	esac

	return 0
}


######## BASE TASK FUNCTIONS ########

function activate_code_env() {
	local code_type="$1"
	local env_name="$2"
	local run_install="$3"
	local title="Loading $code_type environment '$env_name'$([[ "$run_install" != 'true' ]] ||  printf ' (with package install)')"

	print_format "$style_command_title" "$title"

	source "$VENV_ROOT/$code_type/$env_name/bin/activate" || return 1

	if [[ "$run_install" = 'true'  ]]; then
		case "$code_type" in
			"$virtual_env_type_py")
				pip install -r requirements.txt -U || return 1
				;;
			"$virtual_env_type_node")
				npm install || return 1
				git checkout -- package-lock.json || return 1
				;;
		esac
	fi

	return 0
}

function change_dir() {
	local dir_name="$1"
	print_format "$style_command_title" "Changing directory to '$dir_name'"
	cd "$dir_name"
}

function checkout_git_branch() {
	local branch_name="$1"
	print_format "$style_command_title" "Checking out branch '$branch_name'"
	git fetch --all || return 1
	git checkout "$branch_name" || return 1
	git pull || return 1
	return 0
}

function has_file_changes_between_branches_based_on_pattern() {
	local project="$1"
	local branch_from="$2"
	local branch_to="$3"
	local file_pattern_to_find="$4"

	# Want to compare against the remote branch we're going to in case
	# there is no local copy or an outdated local copy
	local remote_branch_to="origin/$branch_to"

	local -i project_i=$(get_project_index "$project")
	local project_dir="${project_dirs[$project_i]}"
	local git_output="$(git --no-pager -C "$project_dir" diff --name-only "${branch_from}..${remote_branch_to}" "$file_pattern_to_find" )"

	if [[ -z "$git_output" ]]; then
		printf "false"
	else
		printf "true"
	fi

	return 0
}

function run_command() {
	print_format "$style_command_title" "Running command '$*'"
	$@
}

function create_clean_db() {
	local db_name="$1"
	local clean_db_name="${db_name}_${clean_db_suffix}"

	print_format "$style_command_title" "Creating clean copy of database '$db_name' as '$clean_db_name'"

	# Create clean copy of database, overwriting it if it already exists
	local base_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '$db_name'" )"
	local clean_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '$clean_db_name'" )"

	if [[ "$base_db_exists" != "1" ]]; then
		print_format "$style_error" "$message_db_does_not_exist: '$db_name'"
		return 1
	fi

	if [[ "$clean_db_exists" = "1" ]]; then
		psql -c "
			DROP DATABASE \"$clean_db_name\";
		" || return 1
	fi

	psql -c "
		CREATE DATABASE \"$clean_db_name\" WITH TEMPLATE \"$db_name\";
	" || return 1

	return 0
}

function restore_from_clean_db() {
	local db_name="$1"
	local delete_clean_db="$2"
	local clean_db_name="${db_name}_${clean_db_suffix}"

	print_format "$style_command_title" "Restoring database '$db_name' from '$clean_db_name'"

	local base_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '$db_name'" )"
	local clean_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '$clean_db_name'" )"

	if [[ "$clean_db_exists" != '1' ]]; then
		print_format "$style_error" "$message_db_does_not_exist: '$clean_db_name'"
		return 1
	fi

	# Stop processes connected to db quickly
	psql -c "
		SELECT pg_terminate_backend(pg_stat_activity.pid)
		FROM pg_stat_activity
		WHERE pg_stat_activity.datname = '$db_name'
		AND pid <> pg_backend_pid();
	" || return 1

	# Drop altered db
	if [[ "$base_db_exists" = '1'  ]]; then
		psql -c "
			DROP DATABASE \"$db_name\";
		" || return 1
	fi

	# Restore clean database to old name
	psql -c "
		CREATE DATABASE \"$db_name\" WITH TEMPLATE \"$clean_db_name\";
	" || return 1

	# Drop clean db if flag is set
	if [ "$delete_clean_db" = 'true' ]; then
		print_format "$style_command_title" "Deleting clean database '$clean_db_name' after successful restore"
		psql -c "
			DROP DATABASE \"$clean_db_name\";
		" || return 1
	fi

	return 0
}

function django_migrate_db() {
	print_format "$style_command_title" 'Django migrate database'
	python manage.py migrate || return 1
}

function load_termsheet_templates() {
	print_format "$style_command_title" 'Loading termsheet templates'
	python manage.py load_termsheet_templates --noinput || return 1
}

function django_start_server() {
	local port="$1"
	print_format "$style_command_title" "Starting django server on port '$port'"
	python manage.py runserver "$port"
}

function django_start_celery() {
	local app_name="$1"
	local priority="$2"

	print_format "$style_command_title" "Starting '$app_name' celery worker $([[ -z "$priority" ]] || printf "%s" "($priority)")"

	if [[ -n "$priority" ]]; then
		celery -A "$app_name" worker -Q "$priority"
	else
		celery -A "$app_name" worker
	fi
}

function npm_run_watch() {
	print_format "$style_command_title" 'Starting npm watch'
	npm run watch
}

function goto_project() {
	local project="$1"
	local run_install="$2"
	local branch="$3"

	local -i project_i=$(get_project_index "$project")
	local project_dir="${project_dirs[$project_i]}"
	local project_virtual_env_type="${project_virtual_env_types[$project_i]}"
	local project_virtual_env_name="${project_virtual_env_names[$project_i]}"

	change_dir "$project_dir" || return 1

	if [[ -n "$branch" ]]; then
		checkout_git_branch "$branch" || return 1
	fi

	activate_code_env "$project_virtual_env_type" "$project_virtual_env_name" "$run_install" || return 1

	return 0
}

function setup_project_branch() {
	local project="$1"
	local run_install="$2"
	local branch="$3"

	local -i project_i=$(get_project_index "$project")
	local project_type="${project_types[$project_i]}"

	goto_project "$project" "$run_install" "$branch" || return 1

	if [[ "$project_type" = "$project_type_django" ]]; then
		# These arguments are only required for django projects
		local run_migrations="$4"
		local load_ts_templates="$5"
		local project_requires_load_ts_templates="${project_requires_load_termsheet_templates[$project_i]}"

		if [[ "$run_migrations" = 'true' ]]; then
			django_migrate_db || return 1
		fi

		if [[ "$project_requires_load_ts_templates" = 'true' && "$load_ts_templates" = 'true'  ]]; then
			load_termsheet_templates || return 1
		fi
	fi

	return 0
}

function run_django_start_server() {
	local project="$1"
	local port="$2"
	goto_project "$project" 'false' || return 1
	django_start_server "$port"
}

function run_django_start_celery() {
	local project="$1"
	local app_name="$2"
	local priority="$3"
	goto_project "$project" 'false' || return 1
	django_start_celery "$app_name" "$priority"
}

function run_npm_run_watch() {
	local project="$1"
	goto_project "$project" 'false' || return 1
	npm_run_watch
}


######## TMUX SESSION MANAGEMENT ########

function get_tmux_session_name_regex() {
	local session_name_regex="^${script_name}"

	# Dynamically builds regex pattern based on projects in config
	for proj_i in "${git_independent_projects[@]}"; do
		local project_short_name="${project_short_names[$proj_i]}"
		session_name_regex+="(${sesh_name_sep}($project_short_name)=([0-9A-z_/.-]+))?"
	done

	session_name_regex+='$'

	printf "$session_name_regex"
}

function run_command_with_tmux_unlock() {
	local tmux_lock_channel="$1"
	shift
	$@ && tmux wait-for -S "$tmux_lock_channel"
}

function get_running_tmux_session_with_regex() {
	local session_name_regex="$1"
	local tmux_sessions=( $(tmux list-sessions -F "#{session_name}") )
	local matched_session_running='false'
	local -i num_of_matched_sessions=0

	for sesh in "${tmux_sessions[@]}"; do
		if [[ "$sesh" =~ $session_name_regex ]]; then
			local matched_session_running='true'
			local num_of_matched_sessions=$((++num_of_matched_sessions))
			if [[ $num_of_matched_sessions -gt 1 ]]; then
				print_format "$style_error" "$message_multiple_running_tmux_sessions. Session #$num_of_matched_sessions: $sesh"
			fi
		fi
	done

	if [[ "$matched_session_running" = 'true' && $num_of_matched_sessions -eq 1 ]]; then
		for match in "${BASH_REMATCH[@]}"; do
			printf "%s\n" "$match"
		done
		return 0
	elif [[ "$matched_session_running" = 'true' ]]; then
		return 2
	else
		return 1
	fi
}

function create_tmux_worker_window() {
	local tmux_session_name="$1"
	local tmux_windows=( $(tmux list-windows -t "$tmux_session_name" -F "#{window_name}") )

	if ! is_in_array "$tmux_window_name_worker" "${tmux_windows[@]}"; then
		tmux new-window -dk -t "$tmux_session_name:0" -n "$tmux_window_name_worker" || return 1
	fi

	return 0
}

function delete_tmux_worker_window() {
	local tmux_session_name="$1"
	local tmux_windows=( $(tmux list-windows -t "$tmux_session_name" -F "#{window_name}") )

	if is_in_array "$tmux_window_name_worker" "${tmux_windows[@]}"; then
		tmux kill-window -t "$tmux_session_name:$tmux_window_name_worker" || return 1
	fi

	return 0
}

function update_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="$3"

	local -i project_i=$(get_project_index "$project")
	local project_dir="${project_dirs[$project_i]}"
	local project_type="${project_types[$project_i]}"
	local tmux_windows=( $(tmux list-windows -t "$tmux_session_name" -F "#{window_name}") )

	if [[ "$update_type" = "$tmux_update_type_set_env_var" && ( -z "$4" || -z "$5" ) ]]; then
		print_format "$style_error" "Environment variables cannot be added as they are not set"
		return 1
	else
		local env_var_key="$4"
		local env_var_value="$5"
	fi

	case "$project_type" in
		"$project_type_django")
			local win_name_django="${project}${tmux_win_name_django_suffix}"
			local win_name_celery="${project}${tmux_win_name_celery_suffix}"
			local project_celery_app_name="${project_celery_app_names[$project_i]}"

			case "$update_type" in
				"$tmux_update_type_create")
					# Creates the windows necessary for the project
					if ! is_in_array "$win_name_django" "${tmux_windows[@]}"; then
						tmux new-window -da -c "$project_dir" -t "$tmux_session_name:{end}" -n "$win_name_django" || return 1
						tmux send-keys -t "$tmux_session_name:$win_name_django" \
							 "tmux wait-for -S $tmux_default_lock_channel" 'C-m' || return 1
						tmux wait-for "$tmux_default_lock_channel"
					fi

					if [[ -n "$project_celery_app_name" ]]; then
						if ! is_in_array "$win_name_celery" "${tmux_windows[@]}"; then
							tmux new-window -da -c "$project_dir" -t "$tmux_session_name:{end}" -n "$win_name_celery" || return 1
							tmux split-window -c "$project_dir" -t "$tmux_session_name:$win_name_celery" || return 1
							tmux send-keys -t "$tmux_session_name:$win_name_celery.1" \
								 "tmux wait-for -S $tmux_default_lock_channel" 'C-m' || return 1
							tmux wait-for "$tmux_default_lock_channel"
						fi
					fi
					;;

				"$tmux_update_type_delete")
					# Deletes the windows for the project
					if is_in_array "$win_name_django" "${tmux_windows[@]}"; then
						tmux kill-window -t "$tmux_session_name:$win_name_django" || return 1
					fi

					if [[ -n "$project_celery_app_name" ]]; then
						if is_in_array "$win_name_celery" "${tmux_windows[@]}"; then
							tmux kill-window -t "$tmux_session_name:$win_name_celery" || return 1
						fi
					fi
					;;

				"$tmux_update_type_kill_sig")
					# Sends a kill signal to all active windows - useful before setting environment variables
					tmux send-keys -t "$tmux_session_name:$win_name_django" 'C-c' || return 1
					if [[ -n "$project_celery_app_name" ]]; then
						tmux send-keys -t "$tmux_session_name:$win_name_celery.0" 'C-c' || return 1
						tmux send-keys -t "$tmux_session_name:$win_name_celery.1" 'C-c' || return 1
					fi
					;;

				"$tmux_update_type_set_env_var")
					# Sets environment variables in the windows of a project
					tmux send-keys -t "$tmux_session_name:$win_name_django" "export $env_var_key=$env_var_value" 'C-m' || return 1

					if [[ -n "$project_celery_app_name" ]]; then
						tmux send-keys -t "$tmux_session_name:$win_name_celery.0" \
							"export $env_var_key=$env_var_value" 'C-m' || return 1

						tmux send-keys -t "$tmux_session_name:$win_name_celery.1" \
							"export $env_var_key=$env_var_value" 'C-m' || return 1
					fi

					# Always send environment variables to the worker to ensure it can run scripts properly
					tmux send-keys -t "$tmux_session_name:$tmux_window_name_worker" \
						"export $env_var_key=$env_var_value && tmux wait-for -S $tmux_default_lock_channel" 'C-m' || return 1
					tmux wait-for "$tmux_default_lock_channel"
					;;
			esac
			;;

		"$project_type_node")
			local win_name_npm_watch="${project}${tmux_win_name_npm_watch_suffix}"

			case "$update_type" in
				"$tmux_update_type_create")
					# Creates the windows necessary for the project
					if ! is_in_array "$win_name_npm_watch" "${tmux_windows[@]}"; then
						tmux new-window -da -c "$project_dir" -t "$tmux_session_name:{end}" -n "$win_name_npm_watch" || return 1
						tmux send-keys -t "$tmux_session_name:$win_name_npm_watch" \
							 "tmux wait-for -S $tmux_default_lock_channel" 'C-m' || return 1
						tmux wait-for "$tmux_default_lock_channel"
					fi
					;;

				"$tmux_update_type_delete")
					# Deletes the windows for the project
					if is_in_array "$win_name_npm_watch" "${tmux_windows[@]}"; then
						tmux kill-window -t "$tmux_session_name:$win_name_npm_watch" || return 1
					fi
					;;

				"$tmux_update_type_kill_sig")
					# Sends a kill signal to all active windows - useful before setting environment variables
					tmux send-keys -t "$tmux_session_name:$win_name_npm_watch" 'C-c' || return 1
					;;

				"$tmux_update_type_set_env_var")
					# Sets environment variables in the windows of a project
					tmux send-keys -t "$tmux_session_name:$win_name_npm_watch" "export $env_var_key=$env_var_value" 'C-m' || return 1

					# Always send environment variables to the worker to ensure it can run scripts properly
					tmux send-keys -t "$tmux_session_name:$tmux_window_name_worker" \
						"export $env_var_key=$env_var_value && tmux wait-for -S $tmux_default_lock_channel" 'C-m' || return 1
					tmux wait-for "$tmux_default_lock_channel"
					;;
			esac
			;;
	esac

	return 0
}

function create_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="$tmux_update_type_create"
	update_tmux_windows_for_project "$tmux_session_name" "$project" "$update_type"
}

function delete_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="$tmux_update_type_delete"
	update_tmux_windows_for_project "$tmux_session_name" "$project" "$update_type"
}

function stop_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="$tmux_update_type_kill_sig"
	update_tmux_windows_for_project "$tmux_session_name" "$project" "$update_type"
}

function load_env_var_in_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local env_var_key="$3"
	local env_var_value="$4"
	local update_type="$tmux_update_type_set_env_var"
	update_tmux_windows_for_project "$tmux_session_name" "$project" "$update_type" "$env_var_key" "$env_var_value"
}

function refresh_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local branch_from="$3"
	local branch_to="$4"
	local force_reload="$5"

	local -i project_i=$(get_project_index "$project")
	local project_dir="${project_dirs[$project_i]}"
	local project_type="${project_types[$project_i]}"

	case "$project_type" in
		"$project_type_django")
			# If there is a currently running session, check what the most effecient way to update is.
			# Otherwise update everything
			if [[ -n "$branch_from" ]]; then
				local run_install="$(has_file_changes_between_branches_based_on_pattern "$project" "$branch_from" \
					"$branch_to" "$file_pattern_py_requirments" )"
				local run_migrations="$(has_file_changes_between_branches_based_on_pattern "$project" "$branch_from" \
					"$branch_to" "$file_pattern_django_migrations" )"
				local load_ts_templates="$(has_file_changes_between_branches_based_on_pattern "$project" "$branch_from" \
					"$branch_to" "$file_pattern_ts_templates" )"
			else
				local run_install='true'
				local run_migrations='true'
				local load_ts_templates='true'
			fi

			local win_name_django="${project}${tmux_win_name_django_suffix}"
			local win_name_celery="${project}${tmux_win_name_celery_suffix}"
			local project_celery_app_name="${project_celery_app_names[$project_i]}"
			local project_port="${project_ports[$project_i]}"

			printf "$project run_install = $run_install\n"
			printf "$project run_migrations = $run_migrations\n"
			printf "$project load_ts_templates = $load_ts_templates\n"

			if [[ -n "$project_celery_app_name" && -n "$branch_from" ]]; then
				# Celery needs to be restarted for any change in code, database or packages
				tmux send-keys -t "$tmux_session_name:$win_name_celery.0" "C-c" "C-l" || return 1
				tmux send-keys -t "$tmux_session_name:$win_name_celery.1" "C-c" "C-l" || return 1
			fi

			if [[ ( "$run_install" = 'true' || "$force_reload" = 'true' ) && -n "$branch_from" ]]; then
				# The django server only needs restarting for changes in packages
				tmux send-keys -t "$tmux_session_name:$win_name_django" "C-c" "C-l" || return 1
			fi

			# Setups the new branch in the most effecient way possible, blocking further execution till it succeeds
			tmux send-keys -t "$tmux_session_name:$tmux_window_name_worker" \
				"om script-run run_command_with_tmux_unlock $tmux_default_lock_channel " \
				"setup_project_branch $project $run_install $branch_to $run_migrations $load_ts_templates" "C-m" || return 1
			tmux wait-for $tmux_default_lock_channel

			if [[ -n "$project_celery_app_name" ]]; then
				# Start up celery once branch is loaded
				tmux send-keys -t "$tmux_session_name:$win_name_celery.0" \
					"om script-run run_django_start_celery $project $project_celery_app_name high_priority" "C-m" || return 1
				tmux send-keys -t "$tmux_session_name:$win_name_celery.1" \
					"om script-run run_django_start_celery $project $project_celery_app_name" "C-m" || return 1
			fi

			if [[ "$run_install" = 'true' || "$force_reload" = 'true' ]]; then
				# Start up django server if new packages were installed or if window was just opened
				tmux send-keys -t "$tmux_session_name:$win_name_django" \
					"om script-run run_django_start_server $project $project_port" "C-m" || return 1
			fi
			;;

		"$project_type_node")
			# If there is a currently running session, check what the most effecient way to update is.
			# Otherwise update everything
			if [[ -n "$branch_from" ]]; then
				local run_install="$(has_file_changes_between_branches_based_on_pattern "$project" "$branch_from" \
					"$branch_to" "$file_pattern_py_requirments" )"
			else
				local run_install='true'
			fi

			local win_name_npm_watch="${project}${tmux_win_name_npm_watch_suffix}"

			printf "$project run_install = $run_install\n"

			if [[ "$run_install" = 'true' || "$force_reload" = 'true' ]]; then
				# If node requirements have changed, npm watch needs to be restarted
				if [[ -n "$branch_from" ]]; then
					tmux send-keys -t "$tmux_session_name:$win_name_npm_watch" "C-c" "C-l" || return 1
				fi

				# Setups the new branch in the most effecient way possible, blocking further execution till it succeeds
				tmux send-keys -t "$tmux_session_name:$tmux_window_name_worker" \
					"om script-run run_command_with_tmux_unlock $tmux_default_lock_channel " \
					"setup_project_branch $project $run_install $branch_to" "C-m" || return 1
				tmux wait-for $tmux_default_lock_channel
				tmux send-keys -t "$tmux_session_name:$win_name_npm_watch" \
					"om script-run run_npm_run_watch $project" "C-m" || return 1
			else
				# No need to restart the npm watch if there are no changes in the node requirements
				tmux send-keys -t "$tmux_session_name:$tmux_window_name_worker" \
					"om script-run setup_project_branch $project $run_install $branch_to" "C-m" || return 1
			fi
			;;
	esac

	return 0
}


######## COMMAND-SPECIFIC FUNCTIONS ########

function handle_base_options() {
	local option="$1"
	local next_arg="$2"

	case "$option" in
		"$option_help" | "$option_help_short")
			printf "$message_usage_help\n"
			;;
		"$option_verbose" | "$option_verbose_short")
			printf "$message_verbose\n"
			verbose_mode='true'
			if [[ -z "$next_arg" ]]; then
				print_format "$style_error" "$message_not_enough_args\n"
				printf "$message_usage_help\n"
				return 1
			fi
			;;
		"$option_version")
			printf "$version\n"
			;;
	esac

	return 0
}

function build() {
	local -a project_branches_from
	local -a project_branches_to
	local -a env_vars_to_set

	if [[ $# -eq 0 ]]; then
		print_format "$style_error" "$message_not_enough_args"
		return 1

	else
		for (( i=1; i<=$#; i+=2 )); do
			local option="${!i}"
			local branch_index=$((i + 1))
			local branch="${!branch_index}"

			if is_valid_build_command_option "$option"; then
				local project
				local -i project_i
				project="$(get_project_from_option "$option")" || return 1
				project_i=$(get_project_index "$project") || return 1

				if [[ $# -lt $branch_index ]]; then
					print_format "$style_error" "$message_incorrect_num_of_args"
					return 1

				else
					project_branches_to[$project_i]="$branch"

					# This is for projects in the same git repository as another project and therefore track its branch
					if is_in_array "$project_i" "${tracked_projects[@]}"; then
						local tracking_project_i="${project_tracked_by[$project_i]}"
						project_branches_to[$tracking_project_i]="${project_branches_to[$project_i]}"
					fi
				fi

			else
				print_format "$style_error" "$message_unknown_arg: $option"
				printf "$message_usage\n"
				return 1
			fi

		done
	fi

	# Starts tmux server only if it is not already running
	tmux start-server || return 1

	local -a tmux_session_rematch
	local tmux_session_name_regex="$(get_tmux_session_name_regex)"
	tmux_session_rematch=( $(get_running_tmux_session_with_regex "$tmux_session_name_regex") )
	local -i tmux_session_rematch_ret=$?
	local tmux_sesh_name_new="${script_name}"

	for proj_i in "${git_independent_projects[@]}"; do
		local branch_to="${project_branches_to[$proj_i]}"

		if [[ -n "$branch_to" ]]; then
			local project_short_name="${project_short_names[$proj_i]}"
			tmux_sesh_name_new+="${sesh_name_sep}${project_short_name}=${branch_to}"
		fi
	done

	if [[ $tmux_session_rematch_ret -ge 2 ]]; then
		# Multiple tmux sessions were found, exiting with error
		return 1

	elif [[ $tmux_session_rematch_ret -eq 1 ]]; then
		# No tmux session was found - creating new environment
		tmux new-session -d -s "$tmux_sesh_name_new" -n "$tmux_window_name_default"

	else
		# Tmux session found, pulling old branch names and updating project windows
		local tmux_sesh_name_old="${tmux_session_rematch[0]}"

		for (( i=0; i<${#tmux_session_rematch[@]}; i++ )); do
			local match="${tmux_session_rematch[$i]}"
			local -i after_match_index=$((i + 1))

			if is_valid_build_command_project "$match"; then
				local project="$match"
				local -i project_i=$(get_project_index "$project")
				project_branches_from[$project_i]="${tmux_session_rematch[$after_match_index]}"

				# This is for projects in the same git repository as another project and therefore track its branch
				if is_in_array "$project_i" "${tracked_projects[@]}"; then
					local tracking_project_i="${project_tracked_by[$project_i]}"
					project_branches_from[$tracking_project_i]="${project_branches_from[$project_i]}"
				fi
			fi
		done

		tmux rename-session -t "$tmux_sesh_name_old" "$tmux_sesh_name_new" || return 1
	fi

	create_tmux_worker_window "$tmux_sesh_name_new" || return 1

	# Load independent projects first and capture env variables needed for dependent projects
	for proj_i in "${independant_project_indices[@]}"; do
		printf "\n"
		printf "proj_i = $proj_i\n"

		local branch_from="${project_branches_from[$proj_i]}"
		local branch_to="${project_branches_to[$proj_i]}"
		local proj_short_name="${project_short_names[$proj_i]}"

		printf "proj_short_name = $proj_short_name\n"
		printf "branch_from = $branch_from\n"
		printf "branch_to = $branch_to\n"

		# TODO: Add functionality for other default branch names to get to kod-dev, om-qa and om-master urls
		if [[ -n "$branch_to" ]]; then
			create_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" || return 1
			refresh_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" "$branch_from" "$branch_to" 'false' || return 1

			if is_in_array "$proj_i" "${projects_with_url_env_var_indices[@]}"; then
				local env_var_url="${project_url_local[$proj_i]}"
				env_vars_to_set["$proj_i"]="$env_var_url"
			fi

		else
			delete_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" || return 1

			if is_in_array "$proj_i" "${projects_with_url_env_var_indices[@]}"; then
				local env_var_url="${project_url_default[$proj_i]}"
				env_vars_to_set["$proj_i"]="$env_var_url"
			fi
		fi
	done

	printf "\n"
	for proj_i in "${!env_vars_to_set[@]}"; do
		local evn="${project_url_env_var_names[$proj_i]}"
		local evv="${env_vars_to_set[$proj_i]}"
		printf "%s\n" "$evn = $evv"
	done

	# Load dependent projects and add env variables from the independent projects
	for proj_i in "${dependant_project_indices[@]}"; do
		printf "\n"
		printf "proj_i = $proj_i\n"

		local branch_from="${project_branches_from[$proj_i]}"
		local branch_to="${project_branches_to[$proj_i]}"
		local proj_short_name="${project_short_names[$proj_i]}"

		printf "proj_short_name = $proj_short_name\n"
		printf "branch_from = $branch_from\n"
		printf "branch_to = $branch_to\n"

		if [[ -n "$branch_to" ]]; then
			create_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" || return 1

			# Stop tmux window process and add the necessary environment variables to them
			stop_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" || return 1

			for env_var_proj_i in "${!env_vars_to_set[@]}"; do
				local env_var_key="${project_url_env_var_names[$env_var_proj_i]}"
				local env_var_value="${env_vars_to_set[$env_var_proj_i]}"
				printf "Setting env variable $env_var_key=$env_var_value\n"
				load_env_var_in_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" \
					"$env_var_key" "$env_var_value" || return 1
			done

			refresh_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" "$branch_from" "$branch_to" 'true' || return 1

		else
			delete_tmux_windows_for_project "$tmux_sesh_name_new" "$proj_short_name" || return 1
		fi
	done

	delete_tmux_worker_window "$tmux_sesh_name_new" || return 1

	return 0
}

function freeze() {
	local project="$1"
	local -i project_i=$(get_project_index "$project")

	if [[ $# -eq 0 ]]; then
		print_format "$style_error" "$message_not_enough_args"
		return 1
	fi

	if [[ $# -ge 2 ]]; then
		if is_valid_freeze_command_option "$2"; then
			local option="$2"

			case "$option" in
				"$option_branch"|"$option_branch_short")
					if [[ $# -ne 3 ]]; then
						print_format "$style_error" "$message_incorrect_num_of_args"
						return 1
					else
						local branch="$3"
					fi
					;;
			esac
		else
			print_format "$style_rror" "$message_unknown_arg: $2"
			printf "$message_usage\n"
			return 1
		fi
	else
		local branch="$freeze_command_default_branch"
	fi

	if is_valid_project_for_freeze_command "$project"; then
		local project_db_name="${project_db_names[$project_i]}"
		setup_project_branch "$project" 'true' "$branch" 'true' 'true' || return 1
		create_clean_db "$project_db_name" || return 1

	elif is_valid_project "$project"; then
		print_format "$style_error" "$message_command_does_not_support_project: '$project'"
		return 1

	else
		print_format "$style_error" "$message_unknown_project: '$project'"
		return 1
	fi

	return 0
}

function restore() {
	local project="$1"

	local -i project_i=$(get_project_index "$project")
	local delete_db='false'

	if [[ $# -eq 0 ]]; then
		print_format "$style_error" "$message_not_enough_args"
		return 1
	fi

	if [[ $# -ge 2 ]]; then
		if is_valid_restore_command_option "$2"; then
			local option="$2"

			case "$option" in
				"$option_delete"|"$option_delete_short")
					local delete_db='true'
					;;
			esac
		else
			print_format "$style_rror" "$message_unknown_arg: $2"
			printf "$message_usage\n"
			return 1
		fi
	fi

	if is_valid_project_for_freeze_command "$project"; then
		local project_db_name="${project_db_names[$project_i]}"
		restore_from_clean_db "$project_db_name" "$delete_db" || return 1

	elif is_valid_project "$project"; then
		print_format "$style_error" "$message_command_does_not_support_project: '$project'"
		return 1

	else
		print_format "$style_error" "$message_unknown_project: '$project'"
		return 1
	fi

	return 0
}

function run() {
	local project="$1"

	if [[ $# -lt 2 ]]; then
		print_format "$style_error" "$message_incorrect_num_of_args"
		return 1
	fi

	if is_valid_run_command_option "$2"; then
		local option="$2"

		case "$option" in
			"$option_branch"|"$option_branch_short")
				if [[ $# -lt 4 ]]; then
					print_format "$style_error" "$message_incorrect_num_of_args"
					return 1
				else
					local branch="$3"
					shift 3
				fi
				;;
		esac
	else
		shift
	fi

	if is_valid_project "$project"; then
		goto_project "$project" 'false' "$branch" || return 1
		run_command "$@" || return 1
	else
		print_format "$style_error" "$message_unknown_project: '$project'"
		return 1
	fi

	return 0
}

# TODO: Check that om is in the PATH
function check() {
	local set_verbose="$1"
	local verbose='false'
	local vars_missing='false'

	if [[ "$verbose_mode" = 'true' || "$set_verbose" = 'true' ]]; then
		local verbose='true'
		print_format "$style_command_title" "$message_check"
	fi

	for ev in "${env_vars_required[@]}"; do
		if [[ -z "${!ev+x}" ]]; then
			local vars_missing='true'
			printf "Checking '$ev'... ${fm_red}UNSET${fm_reset}\n"
		else
			if [[ "$verbose" = 'true' ]]; then
				printf "Checking '$ev'... ${fm_green}OK${fm_reset}\n"
			fi
		fi
	done

	if [[ "$vars_missing" = 'true' ]]; then
		printf "\n${fm_red}CHECK FAILED${fm_reset}\n"
		printf "Please set the ${fm_red}UNSET${fm_reset} environment variables above before running the program\n"
		return 1
	elif [[ "$verbose" = 'true' ]]; then
		printf "\n${fm_green}CHECK PASSED${fm_reset}\n"
	fi

	return 0
}

function print_config() {
	jq '.' "$config_filepath"
}

function reset() {
	local tmux_sessions=( $(tmux list-sessions -F "#{session_name}") )
	local tmux_session_name_regex="$(get_tmux_session_name_regex)"

	for session in "${tmux_sessions[@]}"; do
		if [[ "$session" =~ $tmux_session_name_regex ]]; then
			tmux kill-session -t "$session"
		fi
	done

	tmux wait-for -S "$tmux_default_lock_channel"
}

function script_run() {
	$@ || print_format "$style_error" "$message_function_returned_error"
	return 0
}

function handle_command() {
	local command="$1"

	load_config || return 1
	check || return 1

	shift

	case "$command" in
		"$command_build")
			build "$@" || return 1
			;;
		"$command_freeze")
			freeze "$@" || return 1
			;;
		"$command_restore")
			restore "$@" || return 1
			;;
		"$command_run")
			run "$@" || return 1
			;;
		"$command_check")
			check 'true' || return 1
			;;
		"$command_print_config")
			print_config || return 1
			;;
		"$command_reset")
			reset || return 1
			;;
		"$command_scipt_run")
			script_run "$@" || return 1
			;;
	esac

	return 0
}


######## MAIN SCRIPT ########

function main() {
	if [[ $# -eq 0 ]]; then
		# Not enough arguments passed
		printf "$message_not_enough_args\n\n"
		printf "$message_usage_help\n"
		return 1

	else
		for arg in "$@"; do
			if is_valid_base_option "$arg"; then
				handle_base_options "$@" || return 1
				shift

			elif is_valid_command "$arg"; then
				time handle_command "$@" || return 1
				return 0

			else
				printf "$message_unknown_arg: $arg\n"
				printf "$message_usage\n"
				return 1
			fi
		done
	fi
}

main "$@" || exit 1

