#!/usr/bin/env bash
#
# Name: Stack Builder
# Purpose: A command line tool to manage a stack of projects in a web application.
#
# The tool is used for the following tasks:
#	- Build a stack of projects for specific git branches
#	- Create a local copy of a database before going into a dirty branch
#	- Restore a database to a local clean copy after leaving a dirty branch
#	- Run a command in a specific project from anywhere


######## SHELL OPTIONS ########

set -eE
trap task_failure ERR
trap script_cleanup INT KILL


######## CONSTANTS ########

readonly SCRIPT_NAME='sb'
readonly VERSION='1.0.0'
readonly CONFIG_FILENAME=".${SCRIPT_NAME}config.json"
readonly CONFIG_FILEPATH=~/${CONFIG_FILENAME}

readonly FM_RED="$(tput setaf 1)"
readonly FM_GREEN="$(tput setaf 2)"
readonly FM_YELLOW="$(tput setaf 3)"
readonly FM_MAGENTA="$(tput setaf 5)"
readonly FM_CYAN="$(tput setaf 6)"
readonly FM_BOLD="$(tput bold)"
readonly FM_RESET="$(tput sgr0)"

readonly PRINT_STYLE_TASK_TITLE_QUIET="${FM_YELLOW}${FM_BOLD}TASK:${FM_RESET} %s... "
readonly PRINT_STYLE_TASK_TITLE="
${FM_YELLOW}${FM_BOLD}TASK:${FM_RESET} ${FM_BOLD}%s${FM_RESET}
--------------------------------------------------------------\n"
readonly PRINT_STYLE_OUTPUT="%s\n"
readonly PRINT_STYLE_OUTPUT_ISOLATED="\n%s\n"
readonly PRINT_STYLE_OUTPUT_NO_NEW_LINE="%s"
readonly PRINT_STYLE_LINE_BREAK="\n"
readonly PRINT_STYLE_SUCCESS="${FM_GREEN}${FM_BOLD}%s${FM_RESET}\n"
readonly PRINT_STYLE_FAILURE="${FM_RED}${FM_BOLD}%s${FM_RESET}\n"
readonly PRINT_STYLE_SUCCESS_ISOLATED="\n${PRINT_STYLE_SUCCESS}"
readonly PRINT_STYLE_FAILURE_ISOLATED="\n${PRINT_STYLE_FAILURE}"
readonly PRINT_STYLE_ERROR="${FM_RED}${FM_BOLD}ERROR${FM_RESET} [$(
	date +'%Y-%m-%d T%H:%M:%S'
)]: %s\n"

readonly CODE_TYPE_PY='py'
readonly CODE_TYPE_NODE='node'

readonly PROJECT_TYPE_DJANGO='django'
readonly PROJECT_TYPE_NODE='node'

readonly VALID_CELERY_PRIORITIES=(
	"" # Explicitly blank, aka normal priority
	"high_priority"
)

readonly COMMAND_BUILD='build'
readonly COMMAND_FREEZE='freeze'
readonly COMMAND_RESTORE='restore'
readonly COMMAND_RUN='run'
readonly COMMAND_ATTACH='attach'
readonly COMMAND_LIST='list'
readonly COMMAND_RESET='reset'
readonly COMMAND_CHECK='check'
readonly COMMAND_SCIPT_RUN='script-run'
readonly COMMAND_PRINT_CONFIG='config'
readonly COMMANDS=(
	"${COMMAND_BUILD}"
	"${COMMAND_FREEZE}"
	"${COMMAND_RESTORE}"
	"${COMMAND_RUN}"
	"${COMMAND_ATTACH}"
	"${COMMAND_LIST}"
	"${COMMAND_RESET}"
	"${COMMAND_CHECK}"
	"${COMMAND_SCIPT_RUN}"
	"${COMMAND_PRINT_CONFIG}"
)

readonly OPTION_HELP='--help'
readonly OPTION_HELP_SHORT='-h'
readonly OPTION_VERSION='--version'
readonly OPTION_VERBOSE='--verbose'
readonly OPTION_VERBOSE_SHORT='-v'
readonly ALLOWED_OPTIONS_BASE=(
	"${OPTION_HELP}"
	"${OPTION_HELP_SHORT}"
	"${OPTION_VERBOSE}"
	"${OPTION_VERBOSE_SHORT}"
	"${OPTION_VERSION}"
)

readonly OPTION_BRANCH='--branch'
readonly OPTION_BRANCH_SHORT='-b'
readonly OPTION_DELETE='--delete'
readonly OPTION_DELETE_SHORT='-d'
readonly FREEZE_COMMAND_ALLOWED_OPTIONS=( "${OPTION_BRANCH}" "${OPTION_BRANCH_SHORT}" )
readonly RESTORE_COMMAND_ALLOWED_OPTIONS=( "${OPTION_DELETE}" "${OPTION_DELETE_SHORT}" )
readonly RUN_COMMAND_ALLOWED_OPTIONS=( "${OPTION_BRANCH}" "${OPTION_BRANCH_SHORT}" )

readonly FREEZE_COMMAND_DEFAULT_BRANCH='master'

readonly PROJECT_NAME_REGEX="[A-z][A-z0-9_]+"
readonly PROJECT_CHAR_REGEX="[a-z0-9]"

readonly VALID_BASH_VARNAME_REGEX='^[A-z0-9][A-z0-9_]*$'
readonly VALID_PROJECT_OPTION_LONG="^--${PROJECT_NAME_REGEX}$"
readonly VALID_PROJECT_OPTION_CHAR="^-${PROJECT_CHAR_REGEX}$"

readonly CFG_VALID_PROJECT_NAME_REGEX="^${PROJECT_NAME_REGEX}$"
readonly CFG_VALID_PROJECT_CHAR_REGEX="^${PROJECT_CHAR_REGEX}$"

readonly CFG_BASE_KEY_PROJECTS='projects'

readonly CFG_KEY_NAME='name'
readonly CFG_KEY_SHORT_NAME='shortName'
readonly CFG_KEY_CHAR='char'
readonly CFG_KEY_TYPE='type'
readonly CFG_KEY_DEPENDANT='dependant'
readonly CFG_KEY_PORT='port'
readonly CFG_KEY_CELERY_APP_NAME='celeryAppName'
readonly CFG_KEY_LOAD_TS_TEMPLATES='loadTermsheetTemplates'
readonly CFG_KEY_TRACKS_PROJECT='tracksProject'
readonly CFG_KEY_URLS='urls'
readonly CFG_KEY_ENV_VARIABLES='environmentVariables'

readonly CFG_ENV_VARIABLE_KEY_ROOT_DIR='rootDir'
readonly CFG_ENV_VARIABLE_KEY_VIRTUALENV_PATH='virtualenvPath'
readonly CFG_ENV_VARIABLE_KEY_DB_NAME='dbName'
readonly CFG_ENV_VARIABLE_KEY_URL='url'

readonly CFG_URL_KEY_DEFAULT='default'
readonly CFG_URL_KEY_LOCAL='local'

readonly -a CFG_PROJECT_REQ_KEYS=(
	"${CFG_KEY_NAME}"
	"${CFG_KEY_SHORT_NAME}"
	"${CFG_KEY_CHAR}"
	"${CFG_KEY_TYPE}"
	"${CFG_KEY_DEPENDANT}"
	"${CFG_KEY_ENV_VARIABLES}"
)
readonly -a CFG_PROJECT_REQ_ENV_VARIABLES=(
	"${CFG_ENV_VARIABLE_KEY_ROOT_DIR}"
	"${CFG_ENV_VARIABLE_KEY_VIRTUALENV_PATH}"
)
readonly -a CFG_ALLOWED_PROJECT_TYPES=( "${PROJECT_TYPE_DJANGO}" "${PROJECT_TYPE_NODE}" )
readonly -a CFG_DJANGO_REQ_KEYS=( "${CFG_KEY_PORT}" )
readonly -a CFG_DJANGO_REQ_ENV_VARIABLES=( "${CFG_ENV_VARIABLE_KEY_DB_NAME}" )
readonly -a CFG_REQUIRED_URLS=( "${CFG_URL_KEY_DEFAULT}" "${CFG_URL_KEY_LOCAL}" )

readonly JQ_FILTER_PROJECTS_IT=".${CFG_BASE_KEY_PROJECTS}[]"
readonly JQ_FILTER_PROJECT_ENV_VARIABLES="${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_ENV_VARIABLES}"
readonly JQ_FILTER_PROJECT_URLS="${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_URLS}"

readonly MESSAGE_USAGE="usage: ${SCRIPT_NAME} [${OPTION_HELP}|${OPTION_HELP_SHORT}] [${OPTION_VERBOSE}|${OPTION_VERBOSE_SHORT}] [${OPTION_VERSION}] <command> [<args>]"
readonly MESSAGE_USAGE_HELP="${MESSAGE_USAGE}

There are a number of possible commands:

	${COMMAND_BUILD}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_BUILD} [--<proj_short_name>|-<proj_char> <branch>...]${FM_RESET}
			Builds each specified project and any projects that track it to a specified
			branch. Possible projects depend on your config file

	${COMMAND_FREEZE}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_FREEZE} <project> [${OPTION_BRANCH}|${OPTION_BRANCH_SHORT} <branch>]${FM_RESET}
			Freeze database for project. Uses the master branch by default

	${COMMAND_RESTORE}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_RESTORE} <project> [${OPTION_DELETE}|${OPTION_DELETE_SHORT}]${FM_RESET}
			Restores project database to last time the freeze command was run. Optionally
			removes clean database after successful restore

	${COMMAND_RUN}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_RUN} <project> [${OPTION_BRANCH}|${OPTION_BRANCH_SHORT} <branch>] <shell-command> [<args>]${FM_RESET}
			Loads project environment and runs the required shell command in it

	${COMMAND_ATTACH}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_ATTACH}${FM_RESET}
			Attach to running tmux session for project stack, if one exists

	${COMMAND_LIST}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_LIST}${FM_RESET}
			Lists the running tmux sessions

	${COMMAND_RESET}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_RESET}${FM_RESET}
			Removes tmux sessions and unlocks waiting windows

	${COMMAND_CHECK}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_CHECK}${FM_RESET}
			Checks to ensure all required environment variables are set up and script is
			accessible on your path

	${COMMAND_PRINT_CONFIG}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_PRINT_CONFIG} [<jq-filter>]${FM_RESET}
			Prints out the config file found at ${CONFIG_FILEPATH}. All commands
			depend on this file being accessible. A jq filter can optionally be passed to
			query the config
"

readonly MESSAGE_CONFIG_UNREADABLE="The config file '${CONFIG_FILEPATH}' does not exist or is not readable"
readonly MESSAGE_CFG_NON_UNIQUE_SHORT_NAMES='Project short names in config must be unique'
readonly MESSAGE_CFG_NON_UNIQUE_CHARS='Project chars in config must be unique'
readonly MESSAGE_NAME_ALLOWED_CHARS='Only characters, digits and _ are allowed'
readonly MESSAGE_CFG_INVALID_NAME="has an invalid name: ${MESSAGE_NAME_ALLOWED_CHARS}"
readonly MESSAGE_CFG_INVALID_SHORT_NAME="has an invalid short name: ${MESSAGE_NAME_ALLOWED_CHARS}"
readonly MESSAGE_CFG_INVALID_CHAR='has an invalid char: Only characters or digits are allowed'
readonly MESSAGE_CFG_KEYS_MISSING="requires keys: ${CFG_PROJECT_REQ_KEYS[*]}"
readonly MESSAGE_CFG_ENVV_MISSING="requires env variables: ${CFG_PROJECT_REQ_ENV_VARIABLES[*]}"
readonly MESSAGE_CFG_INVALID_TYPE="is not of the supported types: ${CFG_ALLOWED_PROJECT_TYPES[*]}"
readonly MESSAGE_CFG_INVALID_DJANGO_KEY_SETUP="requires django keys: ${CFG_DJANGO_REQ_KEYS[*]}"
readonly MESSAGE_CFG_INVALID_DJANGO_ENVV_SETUP="requires django env variables: ${CFG_DJANGO_REQ_ENV_VARIABLES[*]}"
readonly MESSAGE_CFG_INVALID_URL_SETUP="requires following urls: ${CFG_REQUIRED_URLS[*]}"

readonly MESSAGE_CHECK='Running environment check...'
readonly MESSAGE_VERBOSE='Verbose mode switched on'
readonly MESSAGE_NOT_ENOUGH_ARGS='Not enough arguments passed'
readonly MESSAGE_UNKNOWN_ARG='Unknown argument'
readonly MESSAGE_INCORRECT_NUM_OF_ARGS='Incorrect number of arguments passed'
readonly MESSAGE_UNKNOWN_PROJECT='Unknown project'
readonly MESSAGE_GIT_PULL_FAILED='Git pull failed as there are local changes that are not in the
remote yet. Please ensure that all local changes are pushed to the remote before trying again'
readonly MESSAGE_COMMAND_DOES_NOT_SUPPORT_PROJECT='This command does not support the project'
readonly MESSAGE_DB_DOES_NOT_EXIST='Database does not exist'
readonly MESSAGE_MULTIPLE_RUNNING_TMUX_SESSIONS='Multiple tmux sessions matched. Number found:'
readonly MESSAGE_FUNCTION_RETURNED_ERROR='Function returned non-zero value'

readonly CLEAN_DB_SUFFIX='clean'

readonly TMUX_CREATE_TYPE_REPLACE='replace'
readonly TMUX_DEFAULT_LOCK_CHANNEL='lock'
readonly TMUX_WINDOW_NAME_DEFAULT='default'
readonly TMUX_WINDOW_NAME_WORKER='worker'
readonly TMUX_WIN_NAME_DJANGO_SUFFIX='_django'
readonly TMUX_WIN_NAME_CELERY_SUFFIX='_celery'
readonly TMUX_WIN_NAME_NPM_WATCH_SUFFIX='_npm_w'
readonly SESH_NAME_SEP=';'

readonly TMUX_UPDATE_TYPE_CREATE='create'
readonly TMUX_UPDATE_TYPE_DELETE='delete'
readonly TMUX_UPDATE_TYPE_STOP='stop'
readonly TMUX_UPDATE_TYPE_SET_ENV_VAR='setenvv'

readonly -a DJANGO_TMUX_WIN_SUFFIXES=(
	"${TMUX_WIN_NAME_DJANGO_SUFFIX}"
	"${TMUX_WIN_NAME_CELERY_SUFFIX}"
)
readonly -a DJANGO_TMUX_WIN_SPLIT=(
	'false'
	'true'
)
readonly -a DJANGO_TMUX_WIN_DEPENDS_ON_CELERY=(
	'false'
	'true'
)
readonly -a DJANGO_TMUX_WIN_COMMANDS=(
	"run_django_start_server"
	"run_django_start_celery"
)
readonly -a NODE_TMUX_WIN_SUFFIXES=(
	"${TMUX_WIN_NAME_NPM_WATCH_SUFFIX}"
)
readonly -a NODE_TMUX_WIN_SPLIT=(
	'false'
)
readonly -a NODE_TMUX_WIN_DEPENDS_ON_CELERY=(
	'false'
)
readonly -a NODE_TMUX_WIN_COMMANDS=(
	"run_npm_run_watch"
)

readonly FILE_PATTERN_PY_REQUIRMENTS='*requirements*'
readonly FILE_PATTERN_NODE_REQUIREMENTS='*package.json*'
readonly FILE_PATTERN_DJANGO_MIGRATIONS='*migrations*'
readonly FILE_PATTERN_TS_TEMPLATES='*fixtures/termsheet_templates*'


######## CONFIG VARIABLES  ########

declare -a cfg_projects
declare -a cfg_project_indices
declare -a cfg_project_names
declare -a cfg_project_short_names
declare -a cfg_project_chars
declare -a cfg_project_types
declare -a cfg_project_dirs
declare -a cfg_project_code_types
declare -a cfg_project_virtualenv_paths
declare -a cfg_project_ports
declare -a cfg_project_requires_load_termsheet_templates
declare -a cfg_project_celery_app_names
declare -a cfg_project_db_names
declare -a cfg_dependant_project_indices
declare -a cfg_independant_project_indices
declare -a cfg_projects_with_url_env_var_indices
declare -a cfg_project_url_env_var_names
declare -a cfg_project_url_local
declare -a cfg_project_url_default
declare -a cfg_tracked_project_indices
declare -a cfg_git_independant_project_indices
declare -a cfg_git_dependant_project_indices
declare -a cfg_project_tracked_by
declare -a cfg_env_vars_required


######## GLOBAL VARIABLES ########

verbose_mode='false'


######## MAPPING FUNCTIONS ########

function get_project_index_varname() {
	local project="$1"
	trap - ERR
	printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "proj_i_${project}"
}

function get_project_index() {
	local project="$1"
	trap - ERR

	if [[ "${project}" =~ $VALID_BASH_VARNAME_REGEX ]]; then
		local project_index_varname="$(get_project_index_varname "${project}")"
	else
		return 1
	fi

	if [[ -z "${!project_index_varname}" ]]; then
		return 1
	fi

	printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "${!project_index_varname}"
	return 0
}

function get_project_from_option() {
	local option="$1"
	trap - ERR

	if [[ "${option}" =~ ${VALID_PROJECT_OPTION_LONG} ]]; then
		project_name="${option:2}"
		printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "${project_name}"

	elif [[ "${option}" =~ ${VALID_PROJECT_OPTION_CHAR} ]]; then
		project_char="${option:1}"
		printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "${project_char}"

	else
		return 1
	fi

	return 0
}


######## UTILITY FUNCTIONS ########

function is_in_array() {
	local search="$1"
	shift
	local arr=( "$@" )

	for val in "${arr[@]}"; do
		if [[ "${search}" == "${val}" ]]; then
			return 0
		fi
	done

	return 1
}

function is_valid_base_option() {
	local option="$1"
	is_in_array "${option}" "${ALLOWED_OPTIONS_BASE[@]}"
}

function is_valid_command() {
	local command="$1"
	is_in_array "${command}" "${COMMANDS[@]}"
}

function is_valid_project() {
	local project="$1"
	is_in_array "${project}" "${cfg_projects[@]}"
}

function is_valid_project_for_freeze_command() {
	local project="$1"
	local -i project_i
	project_i="$(get_project_index "${project}")" || return 1
	[[ "${cfg_project_types[${project_i}]}" == "${PROJECT_TYPE_DJANGO}" ]]
}

function is_valid_project_for_build_command() {
	local project="$1"
	local -i project_i

	project_i="$(get_project_index "${project}")" || return 1

	is_in_array "${project_i}" "${cfg_git_independant_project_indices[@]}" \
		&& is_in_array "${project_i}" "${cfg_project_indices[@]}"
}

function is_valid_freeze_command_option() {
	local option="$1"
	is_in_array "${option}" "${FREEZE_COMMAND_ALLOWED_OPTIONS[@]}"
}

function is_valid_restore_command_option() {
	local option="$1"
	is_in_array "${option}" "${RESTORE_COMMAND_ALLOWED_OPTIONS[@]}"
}

function is_valid_run_command_option() {
	local option="$1"
	is_in_array "${option}" "${RUN_COMMAND_ALLOWED_OPTIONS[@]}"
}

function is_valid_build_command_option() {
	local option="$1"
	local project
	project="$(get_project_from_option "${option}")" || return 1
	is_valid_project_for_build_command "${project}"
}

function raise_error() {
	local error_message="$1"
	printf "${PRINT_STYLE_ERROR}" "${error_message}" >&2
}

function expand_env_variable_values() {
	local -a env_vars=( "$@" )
	trap - ERR

	for env_var in "${env_vars[@]}"; do
		if [[ -z "${!env_var+x}" ]]; then
			printf "${PRINT_STYLE_OUTPUT}" "${env_var}"
		else
			printf "${PRINT_STYLE_OUTPUT}" "${!env_var}"
		fi
	done

	return 0
}

function create_jq_filter_check_for_array_of_keys() {
	local keys=( "$@" )
	local jq_filter=''
	trap - ERR

	for key in "${keys[@]}"; do
		jq_filter+="has(\"${key}\") and "
	done

	jq_filter="${jq_filter% and }"
	printf "${PRINT_STYLE_OUTPUT}" "${jq_filter}"
}

function create_jq_filter_check_for_valid_value() {
	local valid_values=( "$@" )
	local jq_filter=''
	trap - ERR

	for val in "${valid_values[@]}"; do
		jq_filter+="index(\"${val}\") or "
	done

	jq_filter="${jq_filter% or }"
	printf "${PRINT_STYLE_OUTPUT}" "${jq_filter}"
}



######## CONFIG MANAGEMENT ########

function load_config() {
	# Validate and load project stack configuration from JSON file
	local jq_filter_code_types="
		if .${CFG_KEY_TYPE} == \"${PROJECT_TYPE_DJANGO}\"
		then \"${CODE_TYPE_PY}\"
		else .${CFG_KEY_TYPE} end
	"
	local jq_filter_dependent_project_indicies="
		to_entries[] | if .value.${CFG_KEY_DEPENDANT} == true then .key else empty end
	"
	local jq_filter_independent_project_indicies="
		to_entries[] | if .value.${CFG_KEY_DEPENDANT} == false then .key else empty end
	"
	local jq_filter_git_independent_project_indicies="
		to_entries[] | if .value.${CFG_KEY_TRACKS_PROJECT} then empty else .key end
	"
	local jq_filter_git_dependent_project_indicies="
		to_entries[] | if .value.${CFG_KEY_TRACKS_PROJECT} then .key else empty end
	"
	local jq_filter_projects_with_urls_indicies="
		to_entries[] | if .value.${CFG_KEY_URLS} then .key else empty end
	"
	local jq_filter_project_requires_load_ts_templates=".${CFG_KEY_LOAD_TS_TEMPLATES}//false"

	# Read and validate config
	if [[ ! -r "${CONFIG_FILEPATH}" ]]; then
		raise_error "${MESSAGE_CONFIG_UNREADABLE}"
		return 1
	fi

	local config_json_content="$(<"${CONFIG_FILEPATH}")"
	validate_config "${config_json_content}"

	# Get static config parameters
	cfg_projects=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT} | .${CFG_KEY_NAME}, .${CFG_KEY_SHORT_NAME}")
	)
	cfg_project_indices=(
		$(echo "${config_json_content}" \
		| jq -r ".${CFG_BASE_KEY_PROJECTS} | keys[]")
	)
	cfg_project_names=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_NAME}")
	)
	cfg_project_short_names=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_SHORT_NAME}")
	)
	cfg_project_chars=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CHAR}")
	)
	cfg_project_types=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_TYPE}")
	)
	cfg_project_code_types=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_code_types}")
	)
	cfg_dependant_project_indices=(
		$(echo "${config_json_content}" \
		| jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_dependent_project_indicies}")
	)
	cfg_independant_project_indices=(
		$(echo "${config_json_content}" \
		| jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_independent_project_indicies}")
	)
	cfg_env_vars_required=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}[]")
	)
	cfg_git_independant_project_indices=(
		$(echo "${config_json_content}" \
		| jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_git_independent_project_indicies}")
	)
	cfg_git_dependant_project_indices=(
		$(echo "${config_json_content}" \
		| jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_git_dependent_project_indicies}")
	)
	cfg_projects_with_url_env_var_indices=(
		$(echo "${config_json_content}" \
		| jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_projects_with_urls_indicies}")
	)
	cfg_project_url_env_var_names=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_URL}")
	)
	# TODO: Implement arbitrary url names
	cfg_project_url_local=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_URLS}.${CFG_URL_KEY_LOCAL}")
	)
	cfg_project_url_default=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_URLS}.${CFG_URL_KEY_DEFAULT}")
	)
	cfg_project_ports=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_PORT}")
	)
	cfg_project_celery_app_names=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CELERY_APP_NAME}")
	)
	cfg_project_requires_load_termsheet_templates=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_project_requires_load_ts_templates}")
	)

	# Get environment variable config parameters which need to be expanded to their values
	cfg_project_dirs=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_ROOT_DIR}")
	)
	cfg_project_virtualenv_paths=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_VIRTUALENV_PATH}")
	)
	cfg_project_db_names=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_DB_NAME}")
	)

	# Expands environment variable parameters into their values
	cfg_project_dirs=( $(expand_env_variable_values "${cfg_project_dirs[@]}") )
	cfg_project_db_names=( $(expand_env_variable_values "${cfg_project_db_names[@]}") )
	cfg_project_virtualenv_paths=(
		$(expand_env_variable_values "${cfg_project_virtualenv_paths[@]}")
	)

	# Create global variables that map to project indices. Used as keys to all project arrays
	for project_i in "${cfg_project_indices[@]}"; do
		local project_index_varname="$( \
			get_project_index_varname "${cfg_project_short_names[${project_i}]}"
		)"
		local project_index_varname_long="$( \
			get_project_index_varname "${cfg_project_names[${project_i}]}"
		)"
		local project_index_varname_char="$( \
			get_project_index_varname "${cfg_project_chars[${project_i}]}"
		)"

		# Not ideal but seemingly the only way to declare a global variable in a function
		# in Bash3 when the name of that variable is stored in another variable. Otherwise
		# you can simply use name=value syntax
		export ${project_index_varname}="${project_i}"
		export ${project_index_varname_long}="${project_i}"
		export ${project_index_varname_char}="${project_i}"
	done

	# Pull additional config parameters for any git dependant projects
	for project_i in "${cfg_git_dependant_project_indices[@]}"; do
		local tracked_project="$( \
			echo "${config_json_content}" \
			| jq -r ".${CFG_BASE_KEY_PROJECTS}[${project_i}].${CFG_KEY_TRACKS_PROJECT}" \
		)"
		local tracked_project_i="$(get_project_index "${tracked_project}")"
		cfg_tracked_project_indices+=( "${tracked_project_i}" )
		cfg_project_tracked_by["${tracked_project_i}"]="${project_i}"
	done

	return 0
}

function validate_config() {
	local config_json_content="$1"
	local validation_failed='false'

	local jq_filter_unique_check="length == (unique | length)"
	local jq_filter_required_key_check="$( \
		create_jq_filter_check_for_array_of_keys "${CFG_PROJECT_REQ_KEYS[@]}"
	)"
	local jq_filter_required_env_variable_key_check="$( \
		create_jq_filter_check_for_array_of_keys "${CFG_PROJECT_REQ_ENV_VARIABLES[@]}" \
	)"
	local jq_filter_valid_project_type="$( \
		create_jq_filter_check_for_valid_value "${CFG_ALLOWED_PROJECT_TYPES[@]}" \
	)"

	local jq_filter_has_urls="has(\"${CFG_KEY_URLS}\")"
	local jq_filter_urls_required_key_check="$( \
		create_jq_filter_check_for_array_of_keys "${CFG_REQUIRED_URLS[@]}" \
	)"
	local jq_filter_urls_setup_check="
		(${jq_filter_has_urls} | not) or
		((${jq_filter_has_urls}) and (.${CFG_KEY_URLS} | ${jq_filter_urls_required_key_check}))
	"

	local jq_filter_django_required_key_check="$( \
		create_jq_filter_check_for_array_of_keys "${CFG_DJANGO_REQ_KEYS[@]}" \
	)"
	local jq_filter_django_env_variable_required_key_check="$( \
		create_jq_filter_check_for_array_of_keys "${CFG_DJANGO_REQ_ENV_VARIABLES[@]}" \
	)"
	local jq_filter_project_setup_check="
		if .${CFG_KEY_TYPE} == \"${PROJECT_TYPE_DJANGO}\" then
			(
				(${jq_filter_django_required_key_check}) and
				(.${CFG_KEY_ENV_VARIABLES} | ${jq_filter_django_env_variable_required_key_check})
			)
		else true end
	"

	# Grab project names and indices from config for error messages
	local -a cfg_project_indices=(
		$(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | keys[]")
	)
	local -a cfg_project_names=(
		$(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_NAME}")
	)

	# Run validation checks on projects config and store results
	local -a project_names_are_valid=(
		$(echo "${config_json_content}" \
		| jq -r \
		"${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_NAME} | test(\"${CFG_VALID_PROJECT_NAME_REGEX}\")")
	)
	local -a project_short_names_are_valid=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_SHORT_NAME}
			| test(\"${CFG_VALID_PROJECT_NAME_REGEX}\")")
	)
	local -a project_chars_are_valid=(
		$(echo "${config_json_content}" \
		| jq -r \
		"${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CHAR} | test(\"${CFG_VALID_PROJECT_CHAR_REGEX}\")")
	)

	local project_short_names_are_unique="$( \
		echo "${config_json_content}" \
		| jq -r "[${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_SHORT_NAME}] | ${jq_filter_unique_check}" \
	)"
	local project_chars_are_unique="$( \
		echo "${config_json_content}" \
		| jq -r "[${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CHAR}] | ${jq_filter_unique_check}" \
	)"

	local -a projects_have_required_keys=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_required_key_check}")
	)
	local -a projects_have_required_env_variable_keys=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES} | ${jq_filter_required_env_variable_key_check}")
	)
	local -a projects_have_valid_types=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_TYPE} | ${jq_filter_valid_project_type}")
	)
	local -a projects_have_valid_type_setup=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_project_setup_check}")
	)
	local -a projects_have_valid_url_setup=(
		$(echo "${config_json_content}" \
		| jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_urls_setup_check}")
	)

	# Check for failed validation and print errors where required
	# TODO: Find a neater way to choose error messages with less code!
	if [[ "${project_short_names_are_unique}" == 'false' ]]; then
		validation_failed='true'
		raise_error "${MESSAGE_CFG_NON_UNIQUE_SHORT_NAMES}"
	fi

	if [[ "${project_chars_are_unique}" == 'false' ]]; then
		validation_failed='true'
		raise_error "${MESSAGE_CFG_NON_UNIQUE_CHARS}"
	fi

	for project_i in "${!cfg_project_indices[@]}"; do
		local project_name="Project ${project_i} '${cfg_project_names[${project_i}]}'"

		if [[ "${project_names_are_valid[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_INVALID_NAME}"
		fi

		if [[ "${project_short_names_are_valid[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_INVALID_SHORT_NAME}"
		fi

		if [[ "${project_chars_are_valid[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_INVALID_CHAR}"
		fi

		if [[ "${projects_have_required_keys[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_KEYS_MISSING}"
		fi

		if [[ "${projects_have_required_env_variable_keys[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_ENVV_MISSING}"
		fi

		if [[ "${projects_have_valid_types[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_INVALID_TYPE}"
		fi

		if [[ "${projects_have_valid_type_setup[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_INVALID_DJANGO_KEY_SETUP}"
			raise_error "${project_name} ${MESSAGE_CFG_INVALID_DJANGO_ENVV_SETUP}"
		fi

		if [[ "${projects_have_valid_url_setup[${project_i}]}" == 'false' ]]; then
			validation_failed='true'
			raise_error "${project_name} ${MESSAGE_CFG_INVALID_URL_SETUP}"
		fi
	done

	if [[ "${validation_failed}" == 'true' ]]; then
		return 1
	fi

	return 0
}


######## BASE TASK FUNCTIONS ########

function print_task_title() {
	local title="$1"

	if [[ "${verbose_mode}" == 'true' ]]; then
		printf "${PRINT_STYLE_TASK_TITLE}" "${title}"
	else
		printf "${PRINT_STYLE_TASK_TITLE_QUIET}" "${title}"
	fi
}

function task_success() {
	if [[ "${verbose_mode}" == 'true' ]]; then
		printf "${PRINT_STYLE_SUCCESS_ISOLATED}" "DONE"
	else
		printf "${PRINT_STYLE_SUCCESS}" "DONE"
	fi
}

function script_cleanup() {
	unlock_tmux || return 0
	exit 1
}

function task_failure() {
	if [[ "${verbose_mode}" == 'true' ]]; then
		printf "${PRINT_STYLE_FAILURE_ISOLATED}" "FAILED"
	else
		printf "${PRINT_STYLE_FAILURE}" "FAILED"
	fi

	script_cleanup
}

function change_dir() {
	local dir_name="$1"

	print_task_title "Changing directory to '${dir_name}'"
	cd "${dir_name}"

	task_success
	return 0
}

function checkout_git_branch() {
	local branch_name="$1"

	print_task_title "Checking out branch '${branch_name}'"

	if [[ "${verbose_mode}" == 'true' ]]; then
		git fetch --all
		git checkout "${branch_name}"
		git pull --ff-only || {
			printf "${PRINT_STYLE_ERROR}" "${MESSAGE_GIT_PULL_FAILED}"
			task_failure
		}
	else
		git fetch --all &>/dev/null
		git checkout "${branch_name}" &>/dev/null
		git pull --ff-only &>/dev/null || {
			printf "${PRINT_STYLE_LINE_BREAK}"
			printf "${PRINT_STYLE_ERROR}" "${MESSAGE_GIsT_PULL_FAILED}"
			task_failure
		}
	fi

	task_success
	return 0
}

function activate_code_env() {
	local code_type="$1"
	local env_path="$2"
	local run_install="$3"

	local title="Loading ${code_type} environment '${env_path##*/}'$( \
		[[ "${run_install}" != 'true' ]] || echo ' (with package install)' \
	)"

	print_task_title "${title}"

	source "${env_path}/bin/activate"

	if [[ "${run_install}" == 'true'  ]]; then
		case "${code_type}" in
			"${CODE_TYPE_PY}")
				if [[ "${verbose_mode}" == 'true' ]]; then
					pip install -r requirements.txt -U
				else
					pip install -r requirements.txt -U &>/dev/null
				fi
				;;
			"${CODE_TYPE_NODE}")
				if [[ "${verbose_mode}" == 'true' ]]; then
					npm install
					git checkout -- package-lock.json
				else
					npm install &>/dev/null
					git checkout -- package-lock.json &>/dev/null
				fi
				;;
		esac
	fi

	task_success
	return 0
}

function goto_project() {
	local project="$1"
	local run_install="$2"
	local branch="$3"

	local -i project_i="$(get_project_index "${project}")"
	local project_dir="${cfg_project_dirs[${project_i}]}"
	local project_code_type="${cfg_project_code_types[${project_i}]}"
	local project_virtualenv_path="${cfg_project_virtualenv_paths[${project_i}]}"

	change_dir "${project_dir}"

	if [[ -n "${branch}" ]]; then
		checkout_git_branch "${branch}"
	fi

	activate_code_env "${project_code_type}" "${project_virtualenv_path}" "${run_install}"

	return 0
}

function has_file_changes_between_branches_based_on_pattern() {
	local project="$1"
	local branch_from="$2"
	local branch_to="$3"
	local file_pattern_to_find="$4"
	trap - ERR

	# Want to compare against the remote branch we're going to in case
	# there is no local copy or an outdated local copy
	local remote_branch_to="origin/${branch_to}"

	local -i project_i="$(get_project_index "${project}")"
	local project_dir="${cfg_project_dirs[${project_i}]}"
	local git_output="$( \
		git --no-pager -C "${project_dir}" diff --name-only \
		"${branch_from}..${remote_branch_to}" "${file_pattern_to_find}" \
	)"

	if [[ -z "${git_output}" ]]; then
		printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" 'false'
	else
		printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" 'true'
	fi

	return 0
}

function run_command() {
	print_task_title "Running command '$*'"

	# Unlike most tasks, we want the output of this command, even in non-verbose mode
	printf "${PRINT_STYLE_LINE_BREAK}"
	$@

	task_success
	return 0
}

function create_clean_db() {
	local db_name="$1"
	local clean_db_name="${db_name}_${CLEAN_DB_SUFFIX}"

	print_task_title "Creating clean copy of database '${db_name}' as '${clean_db_name}'"

	# Create clean copy of database, overwriting it if it already exists
	local base_db_exists="$(psql -tAc "SELECT 1 FROM pg_database WHERE datname = '${db_name}'")"
	local clean_db_exists="$(psql -tAc \
		"SELECT 1 FROM pg_database WHERE datname = '${clean_db_name}'" \
	)"

	if [[ "${base_db_exists}" != "1" ]]; then
		task_failure
		raise_error "${MESSAGE_DB_DOES_NOT_EXIST}: '${db_name}'"
		return 1
	fi

	if [[ "${clean_db_exists}" == "1" ]]; then
		if [[ "${verbose_mode}" == 'true' ]]; then
			psql -c "DROP DATABASE \"${clean_db_name}\";"
		else
			psql -c "DROP DATABASE \"${clean_db_name}\";" &>/dev/null
		fi
	fi

	if [[ "${verbose_mode}" == 'true' ]]; then
		psql -c "CREATE DATABASE \"${clean_db_name}\" WITH TEMPLATE \"${db_name}\";"
	else
		psql -c "CREATE DATABASE \"${clean_db_name}\" WITH TEMPLATE \"${db_name}\";" &>/dev/null
	fi

	task_success
	return 0
}

function restore_from_clean_db() {
	local db_name="$1"
	local delete_clean_db="$2"
	local clean_db_name="${db_name}_${CLEAN_DB_SUFFIX}"

	print_task_title "Restoring database '${db_name}' from '${clean_db_name}'"

	local base_db_exists="$(psql -tAc "SELECT 1 FROM pg_database WHERE datname = '${db_name}'")"
	local clean_db_exists="$(psql -tAc \
		"SELECT 1 FROM pg_database WHERE datname = '${clean_db_name}'" \
	)"

	if [[ "${clean_db_exists}" != '1' ]]; then
		task_failure
		raise_error "${MESSAGE_DB_DOES_NOT_EXIST}: '${clean_db_name}'"
		return 1
	fi

	if [[ "${base_db_exists}" == '1'  ]]; then

		# Stop processes connected to db quickly and drop the db
		if [[ "${verbose_mode}" == 'true' ]]; then
			psql -c "
				SELECT pg_terminate_backend(pg_stat_activity.pid)
				FROM pg_stat_activity
				WHERE pg_stat_activity.datname = '${db_name}'
				AND pid <> pg_backend_pid();
			"
			psql -c "DROP DATABASE \"${db_name}\";"

		else
			psql -c "
				SELECT pg_terminate_backend(pg_stat_activity.pid)
				FROM pg_stat_activity
				WHERE pg_stat_activity.datname = '${db_name}'
				AND pid <> pg_backend_pid();
			" &>/dev/null

			psql -c "DROP DATABASE \"${db_name}\";" &>/dev/null
		fi

	fi

	# Restore clean database to old name
	if [[ "${verbose_mode}" == 'true' ]]; then
		psql -c "CREATE DATABASE \"${db_name}\" WITH TEMPLATE \"${clean_db_name}\";"
	else
		psql -c "CREATE DATABASE \"${db_name}\" WITH TEMPLATE \"${clean_db_name}\";" &>/dev/null
	fi

	task_success

	# Drop clean db if flag is set
	if [ "${delete_clean_db}" == 'true' ]; then
		print_task_title "Deleting clean database '${clean_db_name}' after successful restore"

		if [[ "${verbose_mode}" == 'true' ]]; then
			psql -c "DROP DATABASE \"${clean_db_name}\";"
		else
			psql -c "DROP DATABASE \"${clean_db_name}\";" &>/dev/null
		fi

		task_success
	fi

	return 0
}

function django_migrate_db() {
	print_task_title 'Django migrate database'

	if [[ "${verbose_mode}" == 'true' ]]; then
		python manage.py migrate
	else
		python manage.py migrate &>/dev/null
	fi

	task_success
	return 0
}

function django_start_server() {
	local port="$1"
	printf "${PRINT_STYLE_TASK_TITLE}" "Starting django server on port '${port}'"
	python manage.py runserver "${port}"
}

function django_start_celery() {
	local app_name="$1"
	local -i priority_i="$2"

	local priority="${VALID_CELERY_PRIORITIES[${priority_i}]}"

	printf "${PRINT_STYLE_TASK_TITLE}" "Starting '${app_name}' celery worker $( \
		[[ -z "${priority}" ]] || echo "(${priority})" \
	)"

	if [[ -n "${priority}" ]]; then
		celery -A "${app_name}" worker -Q "${priority}"
	else
		celery -A "${app_name}" worker
	fi
}

function load_termsheet_templates() {
	print_task_title 'Loading termsheet templates'

	if [[ "${verbose_mode}" == 'true' ]]; then
		python manage.py load_termsheet_templates --noinput
	else
		python manage.py load_termsheet_templates --noinput &>/dev/null
	fi

	task_success
	return 0
}

function npm_run_watch() {
	printf "${PRINT_STYLE_TASK_TITLE}" 'Starting npm watch'
	npm run watch
}

function setup_project_branch() {
	local project="$1"
	local run_install="$2"
	local branch="$3"

	local -i project_i="$(get_project_index "${project}")"
	local project_type="${cfg_project_types[${project_i}]}"

	goto_project "${project}" "${run_install}" "${branch}"

	if [[ "${project_type}" == "${PROJECT_TYPE_DJANGO}" ]]; then
		# These arguments are only required for django projects
		local run_migrations="$4"
		local load_ts_templates="$5"
		local project_requires_load_ts_templates="${cfg_project_requires_load_termsheet_templates[${project_i}]}"

		if [[ "${run_migrations}" == 'true' ]]; then
			django_migrate_db
		fi

		if [[ "${project_requires_load_ts_templates}" == 'true' \
			&& "${load_ts_templates}" == 'true' ]]; then

			load_termsheet_templates
		fi
	fi

	return 0
}

function run_django_start_server() {
	local project="$1"

	local -i project_i="$(get_project_index "${project}")"
	local project_celery_app_name="${cfg_project_celery_app_names[${project_i}]}"
	local project_port="${cfg_project_ports[${project_i}]}"

	goto_project "${project}" 'false'
	django_start_server "${project_port}"
}

function run_django_start_celery() {
	local project="$1"
	local -i priority_i="$2"

	local -i project_i="$(get_project_index "${project}")"
	local project_celery_app_name="${cfg_project_celery_app_names[${project_i}]}"

	goto_project "${project}" 'false'
	django_start_celery "${project_celery_app_name}" "${priority_i}"
}

function run_npm_run_watch() {
	local project="$1"
	goto_project "${project}" 'false'
	npm_run_watch
}


######## TMUX SESSION MANAGEMENT ########

function create_tmux_session() {
	local session_name="$1"

	print_task_title "Creating new tmux session '${session_name}'"

	tmux new-session -d -s "${session_name}" -n "${TMUX_WINDOW_NAME_DEFAULT}"

	task_success
	return 0
}

function kill_tmux_session() {
	local session_name="$1"
	print_task_title "Killing tmux session '${session_name}'"

	tmux kill-session -t "${session}"

	task_success
	return 0
}

function create_tmux_session_name() {
	# Creates tmux session name based on the globabl array variable project_branches_to[]
	local session_name="${SCRIPT_NAME}"

	for proj_i in "${cfg_git_independant_project_indices[@]}"; do
		local branch_to="${project_branches_to[${proj_i}]}"

		if [[ -n "${branch_to}" ]]; then
			local project_short_name="${cfg_project_short_names[${proj_i}]}"
			session_name+="${SESH_NAME_SEP}${project_short_name}=${branch_to}"
		fi
	done

	printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "${session_name}"
	return 0
}

function get_tmux_session_name_regex() {
	local session_name_regex="^${SCRIPT_NAME}"
	trap - ERR

	# Dynamically builds regex pattern based on projects in config
	for proj_i in "${cfg_git_independant_project_indices[@]}"; do
		local project_short_name="${cfg_project_short_names[${proj_i}]}"
		session_name_regex+="(${SESH_NAME_SEP}(${project_short_name})=([0-9A-z_/.-]+))?"
	done

	session_name_regex+='$'

	printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "${session_name_regex}"
}

function get_running_tmux_sessions_with_regex() {
	local session_name_regex="$1"
	local tmux_sessions=( $(tmux list-sessions -F "#{session_name}") )
	trap - ERR

	for session in "${tmux_sessions[@]}"; do
		if [[ "${session}" =~ ${session_name_regex} ]]; then
			printf "${PRINT_STYLE_OUTPUT}" "${session}"
		fi
	done

	return 0
}

function get_branches_from_running_tmux_session_and_update_name() {
	# If there is no tmux session running, then one is created.
	# If there is a tmux session running, the name is updated and the global array variable
	# project_branches_from[] is filled with the branch names running in it
	local tmux_session_name_new="$1"

	local tmux_session_name_regex="$(get_tmux_session_name_regex)"
	local -a tmux_matched_sessions=(
		$(get_running_tmux_sessions_with_regex "${tmux_session_name_regex}")
	)
	local -i num_of_matched_sessions="${#tmux_matched_sessions[@]}"

	if (( num_of_matched_sessions > 1 )); then
		raise_error "${MESSAGE_MULTIPLE_RUNNING_TMUX_SESSIONS} ${num_of_matched_sessions}"
		return 1

	elif (( num_of_matched_sessions == 0 )); then
		create_tmux_session "${tmux_session_name_new}"

	else
		# Tmux session found, pulling old branch names from it
		local tmux_session_name_old="${tmux_matched_sessions[0]}"

		if [[ "${tmux_session_name_old}" =~ ${tmux_session_name_regex} ]]; then

			for i in "${!BASH_REMATCH[@]}"; do
				local match="${BASH_REMATCH[${i}]}"

				if is_valid_project_for_build_command "${match}"; then
					local project="${match}"
					local -i project_i="$(get_project_index "${project}")"
					local -i branch_i=$((i + 1))
					project_branches_from[${project_i}]="${BASH_REMATCH[${branch_i}]}"

					# This is for projects in the same git repository as another project and
					# therefore track its branch
					if is_in_array "${project_i}" "${cfg_tracked_project_indices[@]}"; then
						local tracking_project_i="${cfg_project_tracked_by[${project_i}]}"
						project_branches_from[${tracking_project_i}]="${project_branches_from[${project_i}]}"
					fi
				fi
			done

			tmux rename-session -t "${tmux_session_name_old}" "${tmux_session_name_new}"

		else
			return 1
		fi
	fi

	return 0
}

function create_tmux_window() {
	local window_name="$1"
	local window_target="$2"
	local start_dir="$3"
	local type="$4"

	if [[ -n "${type}" && "${type}" == "${TMUX_CREATE_TYPE_REPLACE}" ]]; then
		local base_flags='-dk'
	else
		local base_flags='-da'
	fi

	if [[ -n "${start_dir}" ]]; then
		tmux new-window ${base_flags} -c "${start_dir}" -t "${window_target}" -n "${window_name}"
	else
		tmux new-window ${base_flags} -t "${window_target}" -n "${window_name}"
	fi

	return 0
}

function split_tmux_window() {
	local window_target="$1"
	local start_dir="$2"

	if [[ -n "${start_dir}" ]]; then
		tmux split-window -c "${start_dir}" -t "${window_target}"
	else
		tmux split-window -t "${window_target}"
	fi

	return 0
}

function kill_tmux_window() {
	local window_target="$1"
	tmux kill-window -t "${window_target}"
	return 0
}

function create_tmux_worker_window() {
	local tmux_session_name="$1"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	if ! is_in_array "${TMUX_WINDOW_NAME_WORKER}" "${tmux_windows[@]}"; then
		create_tmux_window "${TMUX_WINDOW_NAME_WORKER}" "${tmux_session_name}:0" "" \
			"${TMUX_CREATE_TYPE_REPLACE}"
	fi

	return 0
}

function delete_tmux_worker_window() {
	local tmux_session_name="$1"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	if is_in_array "${TMUX_WINDOW_NAME_WORKER}" "${tmux_windows[@]}"; then
		kill_tmux_window "${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}"
	fi

	return 0
}

function lock_tmux() {
	tmux wait-for -L "${TMUX_DEFAULT_LOCK_CHANNEL}"
}

function unlock_tmux() {
	tmux wait-for -U "${TMUX_DEFAULT_LOCK_CHANNEL}" &>/dev/null || return 0
}

function run_command_with_tmux_unlock() {
	$@
	unlock_tmux
}

function create_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"

	local -i project_i="$(get_project_index "${project}")"
	local project_dir="${cfg_project_dirs[${project_i}]}"
	local project_type="${cfg_project_types[${project_i}]}"
	local project_celery_app_name="${cfg_project_celery_app_names[${project_i}]}"
	local end="${tmux_session_name}:{end}"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	case "${project_type}" in
		"${PROJECT_TYPE_DJANGO}")
			local tmux_win_suffixes=( "${DJANGO_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${DJANGO_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_celery=( "${DJANGO_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			;;

		"${PROJECT_TYPE_NODE}")
			local tmux_win_suffixes=( "${NODE_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${NODE_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_celery=( "${NODE_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			;;
	esac

	for tmux_win_i in "${!tmux_win_suffixes[@]}"; do
		local win_name="${project}${tmux_win_suffixes[${tmux_win_i}]}"
		local target_win="${tmux_session_name}:${win_name}"
		local depends_on_cel="${tmux_win_depends_on_celery[${tmux_win_i}]}"
		local split_win="${tmux_win_split[${tmux_win_i}]}"

		if ! is_in_array "${win_name}" "${tmux_windows[@]}" \
			&& [[ "${depends_on_cel}" == 'false' \
			|| ( "${depends_on_cel}" == 'true' && "${project_celery_app_name}" != 'null' ) ]]; then

			create_tmux_window "${win_name}" "${end}" "${project_dir}"

			if [[ "${split_win}" == 'true' ]]; then
				split_tmux_window "${target_win}" "${project_dir}"
			fi
		fi
	done

	return 0
}

function delete_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"

	local -i project_i="$(get_project_index "${project}")"
	local project_type="${cfg_project_types[${project_i}]}"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	case "${project_type}" in
		"${PROJECT_TYPE_DJANGO}")
			local tmux_win_suffixes=( "${DJANGO_TMUX_WIN_SUFFIXES[@]}" )
			;;

		"${PROJECT_TYPE_NODE}")
			local tmux_win_suffixes=( "${NODE_TMUX_WIN_SUFFIXES[@]}" )
			;;
	esac

	for tmux_win_i in "${!tmux_win_suffixes[@]}"; do
		local win_name="${project}${tmux_win_suffixes[${tmux_win_i}]}"

		if is_in_array "${win_name}" "${tmux_windows[@]}"; then
			local target_win="${tmux_session_name}:${win_name}"
			kill_tmux_window "${target_win}"
		fi
	done

	return 0
}

function stop_tmux_windows_for_project() {
	# Sends stop signal to tmux windows. Useful before setting environment variables
	local tmux_session_name="$1"
	local project="$2"

	local -i project_i="$(get_project_index "${project}")"
	local project_type="${cfg_project_types[${project_i}]}"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	case "${project_type}" in
		"${PROJECT_TYPE_DJANGO}")
			local tmux_win_suffixes=( "${DJANGO_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${DJANGO_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_celery=( "${DJANGO_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			;;

		"${PROJECT_TYPE_NODE}")
			local tmux_win_suffixes=( "${NODE_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${NODE_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_celery=( "${NODE_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			;;
	esac

	for tmux_win_i in "${!tmux_win_suffixes[@]}"; do
		local win_name="${project}${tmux_win_suffixes[${tmux_win_i}]}"

		if is_in_array "${win_name}" "${tmux_windows[@]}"; then
			local target_win="${tmux_session_name}:${win_name}"
			local depends_on_cel="${tmux_win_depends_on_celery[${tmux_win_i}]}"
			local split_win="${tmux_win_split[${tmux_win_i}]}"

			if [[ "${split_win}" == 'true' ]]; then
				tmux send-keys -t "${target_win}.0" 'C-c'
				tmux send-keys -t "${target_win}.1" 'C-c'
			else
				tmux send-keys -t "${target_win}" 'C-c'
			fi
		fi
	done

	return 0
}

function load_env_var_in_tmux_windows_for_project() {
	# Sets environment variables in all project windows and the worker
	# window which is shared across differe projects
	local tmux_session_name="$1"
	local project="$2"
	local env_var_key="$3"
	local env_var_value="$4"

	local -i project_i="$(get_project_index "${project}")"
	local project_type="${cfg_project_types[${project_i}]}"
	local target_win_worker="${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}"
	local tmux_unlock="&& ${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} unlock_tmux"
	local env_var_set_cmd_w_unlock="export ${env_var_key}=\"${env_var_value}\" ${tmux_unlock}"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	case "${project_type}" in
		"${PROJECT_TYPE_DJANGO}")
			local tmux_win_suffixes=( "${DJANGO_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${DJANGO_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_celery=( "${DJANGO_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			;;

		"${PROJECT_TYPE_NODE}")
			local tmux_win_suffixes=( "${NODE_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${NODE_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_celery=( "${NODE_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			;;
	esac

	for tmux_win_i in "${!tmux_win_suffixes[@]}"; do
		local win_name="${project}${tmux_win_suffixes[${tmux_win_i}]}"

		if is_in_array "${win_name}" "${tmux_windows[@]}"; then
			local target_win="${tmux_session_name}:${win_name}"
			local depends_on_cel="${tmux_win_depends_on_celery[${tmux_win_i}]}"
			local split_win="${tmux_win_split[${tmux_win_i}]}"

			lock_tmux

			if [[ "${split_win}" == 'true' ]]; then
				tmux send-keys -t "${target_win}.0" "${env_var_set_cmd_w_unlock}" 'C-m'
				lock_tmux
				tmux send-keys -t "${target_win}.1" "${env_var_set_cmd_w_unlock}" 'C-m'
			else
				tmux send-keys -t "${target_win}" "${env_var_set_cmd_w_unlock}" 'C-m'
			fi
		fi
	done

	lock_tmux
	tmux send-keys -t "${target_win_worker}" "${env_var_set_cmd_w_unlock}" 'C-m'

	return 0
}

function reload_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local branch_from="$3"
	local branch_to="$4"
	local force_reload="$5"

	local -i project_i="$(get_project_index "${project}")"
	local project_type="${cfg_project_types[${project_i}]}"
	local target_win_worker="${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}"
	local verbose_flag="$([[ "${verbose_mode}" == 'false' ]] || echo ' -v')"
	local run_cmd="${SCRIPT_NAME}${verbose_flag} ${COMMAND_SCIPT_RUN}"
	local run_cmd_w_unlock="${run_cmd} run_command_with_tmux_unlock"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )
	local hard_reload='false'
	local -a db_args

	case "${project_type}" in
		"${PROJECT_TYPE_DJANGO}")
			local tmux_win_suffixes=( "${DJANGO_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${DJANGO_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_cel=( "${DJANGO_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			local tmux_win_cmd=( "${DJANGO_TMUX_WIN_COMMANDS[@]}" )
			local run_install_file_pattern="${FILE_PATTERN_PY_REQUIRMENTS}"
			local requires_db_commands='true'
			;;

		"${PROJECT_TYPE_NODE}")
			local tmux_win_suffixes=( "${NODE_TMUX_WIN_SUFFIXES[@]}" )
			local tmux_win_split=( "${NODE_TMUX_WIN_SPLIT[@]}" )
			local tmux_win_depends_on_cel=( "${NODE_TMUX_WIN_DEPENDS_ON_CELERY[@]}" )
			local tmux_win_cmd=( "${NODE_TMUX_WIN_COMMANDS[@]}" )
			local run_install_file_pattern="${FILE_PATTERN_PY_REQUIRMENTS}"
			local requires_db_commands='false'
			;;
	esac

	# If there is a currently running session, check for the most effecient way to reload
	if [[ -n "${branch_from}" ]]; then
		local run_install="$( \
			has_file_changes_between_branches_based_on_pattern "${project}" \
			"${branch_from}" "${branch_to}" "${run_install_file_pattern}" \
		)"

		if [[ "${requires_db_commands}" == 'true' ]]; then
			local run_migrations="$( \
				has_file_changes_between_branches_based_on_pattern "${project}" \
				"${branch_from}" "${branch_to}" "${FILE_PATTERN_DJANGO_MIGRATIONS}" \
			)"
			local load_ts_templates="$( \
				has_file_changes_between_branches_based_on_pattern "${project}" \
				"${branch_from}" "${branch_to}" "${FILE_PATTERN_TS_TEMPLATES}" \
			)"
		fi

	else
		local run_install='true'

		if [[ "${requires_db_commands}" == 'true' ]]; then
			local run_migrations='true'
			local load_ts_templates='true'
		fi
	fi

	if [[ "${run_install}" == 'true' || "${force_reload}" == 'true' ]]; then
		hard_reload='true'
	fi

	if [[ "${verbose_mode}" == 'true' ]]; then
		printf "${PRINT_STYLE_OUTPUT}" "Run package install = ${run_install}"

		if [[ "${requires_db_commands}" == 'true' ]]; then
			printf "${PRINT_STYLE_OUTPUT}" "Run database migrations = ${run_migrations}"
			printf "${PRINT_STYLE_OUTPUT}" "Run load_termsheet_templates = ${load_ts_templates}"
		fi
	fi

	# If there is a running branch, stop the windows before reloading them
	if [[ -n "${branch_from}" ]]; then
		lock_tmux

		for tmux_win_i in "${!tmux_win_suffixes[@]}"; do
			local win_name="${project}${tmux_win_suffixes[${tmux_win_i}]}"

			if is_in_array "${win_name}" "${tmux_windows[@]}"; then
				local target_win="${tmux_session_name}:${win_name}"
				local depends_on_cel="${tmux_win_depends_on_cel[${tmux_win_i}]}"
				local split_win="${tmux_win_split[${tmux_win_i}]}"

				# Celery always requires a reload; other services
				# only do so when packages need installing
				if [[ "${hard_reload}" == 'true' || "${depends_on_cel}" == 'true' ]]; then
					if [[ "${split_win}" == 'true' ]]; then
						tmux send-keys -t "${target_win}.0" "C-c" "C-l"
						tmux send-keys -t "${target_win}.1" "C-c" "C-l"
					else
						tmux send-keys -t "${target_win}" "C-c" "C-l"
					fi
				fi
			fi

		done

		unlock_tmux
	fi

	# Sets up the new branch in the most effecient way, locking tmux until it succeeds
	if [[ "${requires_db_commands}" == 'true' ]]; then
		db_args=( "${run_migrations}" "${load_ts_templates}" )
	fi

	if is_in_array 'true' "${tmux_win_depends_on_cel[@]}" || [[ "${hard_reload}" == 'true' ]]; then
		lock_tmux
		tmux send-keys -t "${target_win_worker}" "${run_cmd_w_unlock} setup_project_branch " \
			"${project} ${run_install} ${branch_to} ${db_args[*]}" "C-m"
	else
		tmux send-keys -t "${target_win_worker}" "${run_cmd} setup_project_branch " \
			"${project} ${run_install} ${branch_to} ${db_args[*]}" "C-m"
	fi

	# Restart service in each window with new branch setup
	lock_tmux

	for tmux_win_i in "${!tmux_win_suffixes[@]}"; do
		local win_name="${project}${tmux_win_suffixes[${tmux_win_i}]}"

		if is_in_array "${win_name}" "${tmux_windows[@]}"; then
			local target_win="${tmux_session_name}:${win_name}"
			local depends_on_cel="${tmux_win_depends_on_cel[${tmux_win_i}]}"
			local split_win="${tmux_win_split[${tmux_win_i}]}"
			local win_cmd="${tmux_win_cmd[${tmux_win_i}]} ${project}"

			# Celery always requires a reload; other services
			# only do so when packages need installing
			if [[ "${hard_reload}" == 'true' || "${depends_on_cel}" == 'true' ]]; then
				if [[ "${split_win}" == 'true' ]]; then
					# Commands for split windows are expected to allow a pane index as the last arg
					tmux send-keys -t "${target_win}.0" "${run_cmd} ${win_cmd} 0" "C-m"
					tmux send-keys -t "${target_win}.1" "${run_cmd} ${win_cmd} 1" "C-m"
				else
					tmux send-keys -t "${target_win}" "${run_cmd} ${win_cmd}" "C-m"
				fi
			fi
		fi
	done

	# Free up tmux for other processes
	unlock_tmux

	return 0
}

function build_project_in_tmux_session() {
	# Builds a project in the appropriate tmux windows in the tmux_session_name passed.
	# Function expects the global array variable env_vars_to_set to be accessible
	# Independent projects set their required environment variables in env_vars_to_set
	# and dependent projects use them in their environments
	local -i project_i="$1"
	local dependent="$2"
	local branch_from="$3"
	local branch_to="$4"
	local tmux_session_name="$5"

	local project_short_name="${cfg_project_short_names[${project_i}]}"
	local force_reload="${dependent}"

	# Either creates and builds, or deletes the tmux windows for a project
	# depending on whether we're going to a branch or not
	if [[ -n "${branch_to}" ]]; then
		print_task_title "Building project '${project_short_name}' to branch '${branch_to}'"

		if [[ "${verbose_mode}" == 'true' ]]; then
			printf "${PRINT_STYLE_OUTPUT}" "Branch from = ${branch_from:-none}"
			printf "${PRINT_STYLE_OUTPUT}" "Branch to = ${branch_to}"
		fi

		create_tmux_windows_for_project "${tmux_session_name}" "${project_short_name}"

		# Independent projects have environment variables used by dependent projects
		if [[ "${dependent}" == 'false' ]]; then
			if is_in_array "${project_i}" "${cfg_projects_with_url_env_var_indices[@]}"; then
				local env_var_url="${cfg_project_url_local[${project_i}]}"
				env_vars_to_set["${project_i}"]="${env_var_url}"
			fi

		else
			# Stop tmux window process and add the necessary environment variables to them
			if [[ -n "${branch_from}" ]]; then
				stop_tmux_windows_for_project "${tmux_session_name}" "${project_short_name}"
			fi

			for env_var_project_i in "${!env_vars_to_set[@]}"; do
				local env_var_name="${cfg_project_url_env_var_names[${env_var_project_i}]}"
				local env_var_value="${env_vars_to_set[${env_var_project_i}]}"

				if [[ "${verbose_mode}" == 'true' ]]; then
					printf "${PRINT_STYLE_OUTPUT}" "Setting ${env_var_name}='${env_var_value}'"
				fi

				load_env_var_in_tmux_windows_for_project "${tmux_session_name}" \
					"${project_short_name}" "${env_var_name}" "${env_var_value}"
			done
		fi

		reload_tmux_windows_for_project "${tmux_session_name}" "${project_short_name}" \
			"${branch_from}" "${branch_to}" "${force_reload}"

		task_success
	else
		delete_tmux_windows_for_project "${tmux_session_name}" "${project_short_name}"

		if [[ "${dependent}" == 'false' ]]; then
			if is_in_array "${project_i}" "${cfg_projects_with_url_env_var_indices[@]}"; then
				local env_var_url="${cfg_project_url_default[${project_i}]}"
				env_vars_to_set["${project_i}"]="${env_var_url}"
			fi
		fi
	fi

	return 0
}


######## COMMAND-SPECIFIC FUNCTIONS ########

function handle_base_options() {
	local option="$1"
	local next_arg="$2"

	case "${option}" in
		"${OPTION_HELP}"|"${OPTION_HELP_SHORT}")
			printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_USAGE_HELP}"
			;;

		"${OPTION_VERBOSE}"|"${OPTION_VERBOSE_SHORT}")
			printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_VERBOSE}"
			verbose_mode='true'

			if [[ -z "${next_arg}" ]]; then
				raise_error "${MESSAGE_NOT_ENOUGH_ARGS}"
				printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_USAGE_HELP}"
				return 1
			fi
			;;

		"${OPTION_VERSION}")
			printf "${PRINT_STYLE_OUTPUT}" "${VERSION}"
			;;
	esac

	return 0
}

function build() {
	local -a project_branches_from
	local -a project_branches_to
	local -a env_vars_to_set

	# Handle arguments passed to command
	if (( $# == 0 )); then
		raise_error "${MESSAGE_NOT_ENOUGH_ARGS}"
		return 1

	else
		for (( i=1; i<=$#; i+=2 )); do
			local option="${!i}"

			if is_valid_build_command_option "${option}"; then
				local branch_index=$((i + 1))
				local branch="${!branch_index}"
				local project
				local -i project_i

				project="$(get_project_from_option "${option}")" || return 1
				project_i="$(get_project_index "${project}")" || return 1

				if (( $# < branch_index )); then
					raise_error "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
					return 1

				else
					project_branches_to[${project_i}]="${branch}"

					# This is for projects in the same git repository as another project and
					# therefore track its branch
					if is_in_array "${project_i}" "${cfg_tracked_project_indices[@]}"; then
						local tracking_project_i="${cfg_project_tracked_by[${project_i}]}"
						project_branches_to[${tracking_project_i}]="${project_branches_to[${project_i}]}"
					fi
				fi

			else
				raise_error "${MESSAGE_UNKNOWN_ARG}: ${option}"
				printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_USAGE}"
				return 1
			fi

		done
	fi

	# Starts tmux server only if it is not already running
	tmux start-server

	local tmux_sesh_name_new="$(create_tmux_session_name)"
	get_branches_from_running_tmux_session_and_update_name "${tmux_sesh_name_new}"
	create_tmux_worker_window "${tmux_sesh_name_new}"

	# Load independent projects first and capture env variables needed for dependent projects
	for project_i in "${cfg_independant_project_indices[@]}"; do
		local branch_from="${project_branches_from[${project_i}]}"
		local branch_to="${project_branches_to[${project_i}]}"
		local dependent='false'

		build_project_in_tmux_session "${project_i}" "${dependent}" "${branch_from}" \
			"${branch_to}" "${tmux_sesh_name_new}"
	done

	# Load dependent projects and add env variables from the independent projects
	for project_i in "${cfg_dependant_project_indices[@]}"; do
		local branch_from="${project_branches_from[${project_i}]}"
		local branch_to="${project_branches_to[${project_i}]}"
		local dependent='true'

		build_project_in_tmux_session "${project_i}" "${dependent}" "${branch_from}" \
			"${branch_to}" "${tmux_sesh_name_new}"
	done

	delete_tmux_worker_window "${tmux_sesh_name_new}"

	return 0
}

function freeze() {
	local project="$1"
	local -i project_i="$(get_project_index "${project}")"

	if (( $# == 0 )); then
		raise_error "${MESSAGE_NOT_ENOUGH_ARGS}"
		return 1
	fi

	if (( $# >= 2 )); then
		if is_valid_freeze_command_option "$2"; then
			local option="$2"

			case "${option}" in
				"${OPTION_BRANCH}"|"${OPTION_BRANCH_SHORT}")
					if [[ $# -ne 3 ]]; then
						raise_error "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
						return 1
					else
						local branch="$3"
					fi
					;;
			esac
		else
			raise_error "${MESSAGE_UNKNOWN_ARG}: $2"
			printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_USAGE}"
			return 1
		fi
	else
		local branch="${FREEZE_COMMAND_DEFAULT_BRANCH}"
	fi

	if is_valid_project_for_freeze_command "${project}"; then
		local project_db_name="${cfg_project_db_names[${project_i}]}"
		setup_project_branch "${project}" 'true' "${branch}" 'true' 'true'
		create_clean_db "${project_db_name}"

	elif is_valid_project "${project}"; then
		raise_error "${MESSAGE_COMMAND_DOES_NOT_SUPPORT_PROJECT}: '${project}'"
		return 1

	else
		raise_error "${MESSAGE_UNKNOWN_PROJECT}: '${project}'"
		return 1
	fi

	return 0
}

function restore() {
	local project="$1"

	local -i project_i="$(get_project_index "${project}")"
	local delete_db='false'

	if (( $# == 0 )); then
		raise_error "${MESSAGE_NOT_ENOUGH_ARGS}"
		return 1
	fi

	if (( $# >= 2 )); then
		if is_valid_restore_command_option "$2"; then
			local option="$2"

			case "${option}" in
				"${OPTION_DELETE}"|"${OPTION_DELETE_SHORT}")
					local delete_db='true'
					;;
			esac
		else
			raise_error "${MESSAGE_UNKNOWN_ARG}: $2"
			printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_USAGE}"
			return 1
		fi
	fi

	if is_valid_project_for_freeze_command "${project}"; then
		local project_db_name="${cfg_project_db_names[${project_i}]}"
		restore_from_clean_db "${project_db_name}" "${delete_db}"

	elif is_valid_project "${project}"; then
		raise_error "${MESSAGE_COMMAND_DOES_NOT_SUPPORT_PROJECT}: '${project}'"
		return 1

	else
		raise_error "${MESSAGE_UNKNOWN_PROJECT}: '${project}'"
		return 1
	fi

	return 0
}

function run() {
	local project="$1"

	if (( $# < 2 )); then
		raise_error "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
		return 1
	fi

	if is_valid_run_command_option "$2"; then
		local option="$2"

		case "${option}" in
			"${OPTION_BRANCH}"|"${OPTION_BRANCH_SHORT}")
				if (( $# < 4 )); then
					raise_error "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
					return 1
				else
					local branch="$3"
					shift 3
				fi
				;;
		esac
	else
		shift
	fi

	if is_valid_project "${project}"; then
		goto_project "${project}" 'false' "${branch}"
		run_command "$@"
	else
		raise_error "${MESSAGE_UNKNOWN_PROJECT}: '${project}'"
		return 1
	fi

	return 0
}

function attach() {
	tmux attach -t "${SCRIPT_NAME}"
}

function list() {
	tmux ls
}

function reset() {
	local tmux_sessions=( $(tmux list-sessions -F "#{session_name}") )
	local tmux_session_name_regex="$(get_tmux_session_name_regex)"

	for session in "${tmux_sessions[@]}"; do
		if [[ "${session}" =~ ${tmux_session_name_regex} ]]; then
			kill_tmux_session "${session}"
		fi
	done

	unlock_tmux || return 0
}

function check() {
	local set_verbose="$1"
	local verbose='false'
	local vars_missing='false'
	local command_on_path='true'

	if [[ "${verbose_mode}" == 'true' || "${set_verbose}" == 'true' ]]; then
		local verbose='true'
		printf "${PRINT_STYLE_TASK_TITLE}" "${MESSAGE_CHECK}"
	fi

	for ev in "${cfg_env_vars_required[@]}"; do
		if [[ -z "${!ev+x}" ]]; then
			local vars_missing='true'
			printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "Checking '${ev}' is set... "
			printf "${PRINT_STYLE_FAILURE}" "UNSET"
		else
			if [[ "${verbose}" == 'true' ]]; then
				printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "Checking '${ev}' is set... "
				printf "${PRINT_STYLE_SUCCESS}" "OK"
			fi
		fi
	done

	# Checks if the script is on the PATH
	if command -v "${SCRIPT_NAME}" &>/dev/null; then
		if [[ "${verbose}" == 'true' ]]; then
			printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "Checking '${SCRIPT_NAME}' is on PATH... "
			printf "${PRINT_STYLE_SUCCESS}" "OK"
		fi

	else
		command_on_path='false'
		printf "${PRINT_STYLE_OUTPUT_NO_NEW_LINE}" "Checking '${SCRIPT_NAME}' is on PATH... "
		printf "${PRINT_STYLE_FAILURE}" "NOT FOUND"
	fi

	if [[ "${vars_missing}" == 'true' || "${command_on_path}" == 'false' ]]; then
		printf "${PRINT_STYLE_FAILURE_ISOLATED}" "CHECK FAILED"
		printf "${PRINT_STYLE_OUTPUT}" \
			"Please resolve issues in ${FM_RED}${FM_BOLD}RED${FM_RESET} before running the program"
		return 1

	elif [[ "${verbose}" == 'true' ]]; then
		printf "${PRINT_STYLE_SUCCESS_ISOLATED}" "CHECK PASSED"
	fi

	return 0
}

function print_config() {
	local jq_filter="${1:-.}"
	jq "${jq_filter}" "${CONFIG_FILEPATH}"
}

function script_run() {
	$@ || {
		raise_error "${MESSAGE_FUNCTION_RETURNED_ERROR}"
		return 1
	}
	return 0
}

function handle_command() {
	local command="$1"

	load_config

	shift

	case "${command}" in
		"${COMMAND_BUILD}")
			check
			build "$@"
			;;
		"${COMMAND_FREEZE}")
			check
			freeze "$@"
			;;
		"${COMMAND_RESTORE}")
			check
			restore "$@"
			;;
		"${COMMAND_RUN}")
			check
			run "$@"
			;;
		"${COMMAND_ATTACH}")
			check
			attach
			;;
		"${COMMAND_LIST}")
			check
			list
			;;
		"${COMMAND_RESET}")
			check
			reset
			;;
		"${COMMAND_CHECK}")
			check 'true'
			;;
		"${COMMAND_PRINT_CONFIG}")
			check
			print_config "$@"
			;;
		"${COMMAND_RESET}")
			check
			reset
			;;
		"${COMMAND_SCIPT_RUN}")
			check
			script_run "$@"
			;;
	esac

	return 0
}


######## MAIN SCRIPT ########

function main() {
	if (( $# == 0 )); then
		# Not enough arguments passed
		printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_NOT_ENOUGH_ARGS}"
		printf "${PRINT_STYLE_OUTPUT_ISOLATED}" "${MESSAGE_USAGE_HELP}"
		return 1

	else
		for arg in "$@"; do
			if is_valid_base_option "${arg}"; then
				handle_base_options "$@"
				shift

			elif is_valid_command "${arg}"; then
				time handle_command "$@"
				return 0

			else
				printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_UNKNOWN_ARG}: ${arg}"
				printf "${PRINT_STYLE_OUTPUT}" "${MESSAGE_USAGE}"
				return 1
			fi
		done
	fi
}

main "$@"
