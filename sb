#!/usr/bin/env bash

######## CONSTANTS ########

readonly SCRIPT_NAME='sb'
readonly VERSION='1.0.0'
readonly CONFIG_FILENAME=".${SCRIPT_NAME}config.json"
readonly CONFIG_FILEPATH=~/${CONFIG_FILENAME}

readonly FM_RED="$(tput setaf 1)"
readonly FM_GREEN="$(tput setaf 2)"
readonly FM_YELLOW="$(tput setaf 3)"
readonly FM_MAGENTA="$(tput setaf 5)"
readonly FM_CYAN="$(tput setaf 6)"
readonly FM_BOLD="$(tput bold)"
readonly FM_UNDERLINE="$(tput smul)"
readonly FM_RESET="$(tput sgr0)"

readonly STYLE_COMMAND_TITLE='cmd'
readonly STYLE_ERROR='err'

readonly VIRTUAL_ENV_TYPE_PY='py'
readonly VIRTUAL_ENV_TYPE_NODE='node'

readonly PROJECT_TYPE_DJANGO='django'
readonly PROJECT_TYPE_NODE='node'

readonly COMMAND_BUILD='build'
readonly COMMAND_FREEZE='freeze'
readonly COMMAND_RESTORE='restore'
readonly COMMAND_RUN='run'
readonly COMMAND_CHECK='check'
readonly COMMAND_SCIPT_RUN='script-run'
readonly COMMAND_PRINT_CONFIG='print-config'
readonly COMMAND_RESET='reset'
readonly COMMANDS=(
	"${COMMAND_BUILD}"
	"${COMMAND_FREEZE}"
	"${COMMAND_RESTORE}"
	"${COMMAND_RUN}"
	"${COMMAND_CHECK}"
	"${COMMAND_SCIPT_RUN}"
	"${COMMAND_PRINT_CONFIG}"
	"${COMMAND_RESET}"
)

readonly OPTION_HELP='--help'
readonly OPTION_HELP_SHORT='-h'
readonly OPTION_VERSION='--version'
readonly OPTION_VERBOSE='--verbose'
readonly OPTION_VERBOSE_SHORT='-v'
readonly ALLOWED_OPTIONS_BASE=(
	"${OPTION_HELP}"
	"${OPTION_HELP_SHORT}"
	"${OPTION_VERBOSE}"
	"${OPTION_VERBOSE_SHORT}"
	"${OPTION_VERSION}"
)

readonly OPTION_BRANCH='--branch'
readonly OPTION_BRANCH_SHORT='-b'
readonly OPTION_DELETE='--delete'
readonly OPTION_DELETE_SHORT='-d'
readonly FREEZE_COMMAND_ALLOWED_OPTIONS=( "${OPTION_BRANCH}" "${OPTION_BRANCH_SHORT}" )
readonly RESTORE_COMMAND_ALLOWED_OPTIONS=( "${OPTION_DELETE}" "${OPTION_DELETE_SHORT}" )
readonly RUN_COMMAND_ALLOWED_OPTIONS=( "${OPTION_BRANCH}" "${OPTION_BRANCH_SHORT}" )

readonly FREEZE_COMMAND_DEFAULT_BRANCH='master'

readonly MESSAGE_USAGE="usage: ${SCRIPT_NAME} [${OPTION_HELP}|${OPTION_HELP_SHORT}] [${OPTION_VERSION}] [${OPTION_VERBOSE}|${OPTION_VERBOSE_SHORT}] <command> [<args>]"
readonly MESSAGE_USAGE_HELP="${MESSAGE_USAGE}

There are a number of possible commands:

	${FM_YELLOW}${COMMAND_BUILD}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_BUILD} [--<project_short_name>|-<proj_cli_char> <project-branch>...]${FM_RESET}
			Builds each specified project and its dependant services with the specified
			branches. Possible projects depend on your config file

	${FM_YELLOW}${COMMAND_FREEZE}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_FREEZE} <project> [${OPTION_BRANCH}|${OPTION_BRANCH_SHORT} <branch>]${FM_RESET}
			Freeze database for project. Uses the master branch by default

	${FM_YELLOW}${COMMAND_RESTORE}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_RESTORE} <project> [${OPTION_DELETE}|${OPTION_DELETE_SHORT}]${FM_RESET}
			Restores project database to last time the freeze command was run. Optionally
			removes clean database after successful restore

	${FM_YELLOW}${COMMAND_RUN}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_RUN} <project> [${OPTION_BRANCH}|${OPTION_BRANCH_SHORT} <branch>] <command> [<args>]${FM_RESET}
			Loads project environment and runs required command in it

	${FM_YELLOW}${COMMAND_CHECK}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_CHECK}${FM_RESET}
			Checks to ensure all required environment variables are set up and script is
			accessible on your path

	${FM_YELLOW}${COMMAND_RESET}		${FM_CYAN}${SCRIPT_NAME} ${COMMAND_RESET}${FM_RESET}
			Removes tmux sessions and unlocks waiting windows

	${FM_YELLOW}${COMMAND_PRINT_CONFIG}	${FM_CYAN}${SCRIPT_NAME} ${COMMAND_PRINT_CONFIG}${FM_RESET}
			Prints out the config file found at ${CONFIG_FILEPATH}. All commands
			depend on this file being accessible
"
readonly MESSAGE_CONFIG_FILE_NOT_READABLE="The config file '${CONFIG_FILEPATH}' does not exist or is not readable"
readonly MESSAGE_CHECK='Running environment check...'
readonly MESSAGE_VERBOSE='Verbose mode switched on'
readonly MESSAGE_NOT_ENOUGH_ARGS='Not enough arguments passed'
readonly MESSAGE_UNKNOWN_ARG='Unknown argument'
readonly MESSAGE_INCORRECT_NUM_OF_ARGS='Incorrect number of arguments passed'
readonly MESSAGE_UNKNOWN_PROJECT='Unknown project'
readonly MESSAGE_COMMAND_DOES_NOT_SUPPORT_PROJECT='This command does not support the project'
readonly MESSAGE_DB_DOES_NOT_EXIST='Database does not exist'
readonly MESSAGE_MULTIPLE_RUNNING_TMUX_SESSIONS='Multiple running tmux sessions'
readonly MESSAGE_FUNCTION_RETURNED_ERROR='Function returned non-zero value'

readonly CLEAN_DB_SUFFIX='clean'
readonly TMUX_DEFAULT_LOCK_CHANNEL='lock'
readonly TMUX_WINDOW_NAME_DEFAULT='default'
readonly TMUX_WINDOW_NAME_WORKER='worker'
readonly TMUX_WIN_NAME_DJANGO_SUFFIX='_django'
readonly TMUX_WIN_NAME_CELERY_SUFFIX='_celery'
readonly TMUX_WIN_NAME_NPM_WATCH_SUFFIX='_npm_w'
readonly SESH_NAME_SEP=';'

readonly TMUX_UPDATE_TYPE_CREATE='create'
readonly TMUX_UPDATE_TYPE_DELETE='delete'
readonly TMUX_UPDATE_TYPE_KILL_SIG='killsig'
readonly TMUX_UPDATE_TYPE_SET_ENV_VAR='setenvv'

readonly FILE_PATTERN_PY_REQUIRMENTS='*requirements*'
readonly FILE_PATTERN_NODE_REQUIREMENTS='*package.json*'
readonly FILE_PATTERN_DJANGO_MIGRATIONS='*migrations*'
readonly FILE_PATTERN_TS_TEMPLATES='*fixtures/termsheet_templates*'

readonly NAME_REGEX="[A-z][A-z0-9_]+"
readonly CHAR_REGEX="[a-z0-9]"

readonly VALID_PROJECT_OPTION_LONG="^--${NAME_REGEX}$"
readonly VALID_PROJECT_OPTION_CHAR="^-${CHAR_REGEX}$"

readonly CFG_VALID_NAME_REGEX="^${NAME_REGEX}$"
readonly CFG_VALID_CHAR_REGEX="^${CHAR_REGEX}$"

readonly CFG_BASE_KEY_PROJECTS='projects'

readonly CFG_KEY_NAME='name'
readonly CFG_KEY_SHORT_NAME='shortName'
readonly CFG_KEY_CLI_CHAR='cliChar'
readonly CFG_KEY_TYPE='type'
readonly CFG_KEY_DEPENDANT='dependant'
readonly CFG_KEY_PORT='port'
readonly CFG_KEY_CELERY_APP_NAME='celeryAppName'
readonly CFG_KEY_LOAD_TS_TEMPLATES='loadTermsheetTemplates'
readonly CFG_KEY_TRACKS_PROJECT='tracksProject'
readonly CFG_KEY_URLS='urls'
readonly CFG_KEY_ENV_VARIABLES='environmentVariables'

readonly CFG_ENV_VARIABLE_KEY_ROOT_DIR='rootDir'
readonly CFG_ENV_VARIABLE_KEY_ENV_NAME='envName'
readonly CFG_ENV_VARIABLE_KEY_DB_NAME='dbName'
readonly CFG_ENV_VARIABLE_KEY_URL='url'

readonly CFG_URL_KEY_DEFAULT='default'
readonly CFG_URL_KEY_LOCAL='local'

readonly -a CFG_PROJECT_REQUIRED_FIELDS=(
	"${CFG_KEY_NAME}"
	"${CFG_KEY_SHORT_NAME}"
	"${CFG_KEY_CLI_CHAR}"
	"${CFG_KEY_TYPE}"
	"${CFG_KEY_DEPENDANT}"
	"${CFG_KEY_ENV_VARIABLES}"
)
readonly -a CFG_PROJECT_REQUIRED_ENV_VARIABLE_FIELDS=(
	"${CFG_ENV_VARIABLE_KEY_ROOT_DIR}"
	"${CFG_ENV_VARIABLE_KEY_ENV_NAME}"
)
readonly -a CFG_ALLOWED_PROJECT_TYPES=(
	"${PROJECT_TYPE_DJANGO}"
	"${PROJECT_TYPE_NODE}"
)
readonly -a CFG_DJANGO_REQUIRED_FIELDS=("${CFG_KEY_PORT}")
readonly -a CFG_DJANGO_REQUIRED_ENV_VARIABLE_FIELDS=("${CFG_ENV_VARIABLE_KEY_DB_NAME}")
readonly -a CFG_REQUIRED_URLS=(
	"${CFG_URL_KEY_DEFAULT}"
	"${CFG_URL_KEY_LOCAL}"
)

readonly JQ_FILTER_PROJECTS_IT=".${CFG_BASE_KEY_PROJECTS}[]"
readonly JQ_FILTER_PROJECT_ENV_VARIABLES="${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_ENV_VARIABLES}"
readonly JQ_FILTER_PROJECT_URLS="${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_URLS}"


######## CONFIG VARIABLES  ########

declare -a cfg_projects
declare -a cfg_project_indices
declare -a cfg_project_names
declare -a cfg_project_short_names
declare -a cfg_project_chars
declare -a cfg_project_types
declare -a cfg_project_dirs
declare -a cfg_project_virtual_env_types
declare -a cfg_project_virtual_env_names
declare -a cfg_project_ports
declare -a cfg_project_requires_load_termsheet_templates
declare -a cfg_project_celery_app_names
declare -a cfg_project_db_names
declare -a cfg_dependant_project_indices
declare -a cfg_independant_project_indices
declare -a cfg_projects_with_url_env_var_indices
declare -a cfg_project_url_env_var_names
declare -a cfg_project_url_local
declare -a cfg_project_url_default
declare -a cfg_tracked_projects
declare -a cfg_git_independant_project_indices
declare -a cfg_git_dependant_project_indices
declare -a cfg_project_tracked_by
declare -a cfg_env_vars_required


######## GLOBAL VARIABLES ########

verbose_mode='false'


######## CONFIG MANAGEMENT ########

function expand_env_variable_values() {
	local -a env_vars=("$@")

	for env_var in "${env_vars[@]}"; do
		if [[ -z "${!env_var+x}" ]]; then
			printf "${env_var}\n"
		else
			printf "${!env_var}\n"
		fi
	done

	return 0
}

function load_config() {
	local jq_filter_virtual_env_types="if .${CFG_KEY_TYPE} == \"${PROJECT_TYPE_DJANGO}\" then \"${VIRTUAL_ENV_TYPE_PY}\" else .${CFG_KEY_TYPE} end"
	local jq_filter_dependent_project_indicies="to_entries[] | if .value.${CFG_KEY_DEPENDANT} == true then .key else empty end"
	local jq_filter_independent_project_indicies="to_entries[] | if .value.${CFG_KEY_DEPENDANT} == false then .key else empty end"
	local jq_filter_git_independent_project_indicies="to_entries[] | if .value.${CFG_KEY_TRACKS_PROJECT} then empty else .key end"
	local jq_filter_git_dependent_project_indicies="to_entries[] | if .value.${CFG_KEY_TRACKS_PROJECT} then .key else empty end"
	local jq_filter_projects_with_urls_indicies="to_entries[] | if .value.${CFG_KEY_URLS} then .key else empty end"
	local jq_filter_project_required_load_ts_templates=".${CFG_KEY_LOAD_TS_TEMPLATES}//false"

	if [[ ! -r "${CONFIG_FILEPATH}" ]]; then
		print_format "${STYLE_ERROR}" "${MESSAGE_CONFIG_FILE_NOT_READABLE}"
		return 1
	fi

	local config_json_content="$(<"${CONFIG_FILEPATH}")"
	validate_config "${config_json_content}" || return 1

	# Get static config parameters
	cfg_projects=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT} | .${CFG_KEY_NAME}, .${CFG_KEY_SHORT_NAME}") )
	cfg_project_indices=( $(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | keys[]") )
	cfg_project_names=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_NAME}") )
	cfg_project_short_names=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_SHORT_NAME}") )
	cfg_project_chars=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CLI_CHAR}") )
	cfg_project_types=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_TYPE}") )
	cfg_project_virtual_env_types=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_virtual_env_types}") )
	cfg_dependant_project_indices=( $(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_dependent_project_indicies}") )
	cfg_independant_project_indices=( $(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_independent_project_indicies}") )
	cfg_env_vars_required=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}[]") )
	cfg_git_independant_project_indices=( $(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_git_independent_project_indicies}") )
	cfg_git_dependant_project_indices=( $(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_git_dependent_project_indicies}") )
	cfg_projects_with_url_env_var_indices=( $(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | ${jq_filter_projects_with_urls_indicies}") )
	cfg_project_url_env_var_names=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_URL}") )
	# TODO: Implement arbitrary url names
	cfg_project_url_local=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_URLS}.${CFG_URL_KEY_LOCAL}") )
	cfg_project_url_default=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_URLS}.${CFG_URL_KEY_DEFAULT}") )
	cfg_project_ports=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_PORT}") )
	cfg_project_celery_app_names=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CELERY_APP_NAME}") )
	cfg_project_requires_load_termsheet_templates=(
		$(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_project_required_load_ts_templates}")
	)

	# Get environment variable config parameters
	cfg_project_dirs=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_ROOT_DIR}") )
	cfg_project_virtual_env_names=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_ENV_NAME}") )
	cfg_project_db_names=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES}.${CFG_ENV_VARIABLE_KEY_DB_NAME}") )

	# Expands environment variables into their values
	cfg_project_dirs=( $(expand_env_variable_values "${cfg_project_dirs[@]}") )
	cfg_project_virtual_env_names=( $(expand_env_variable_values "${cfg_project_virtual_env_names[@]}") )
	cfg_project_db_names=( $(expand_env_variable_values "${cfg_project_db_names[@]}") )

	# Create global variables to index projects
	for project_i in "${cfg_project_indices[@]}"; do
		local project_index_varname="$(get_project_index_varname "${cfg_project_short_names[${project_i}]}")"
		local project_index_varname_long="$(get_project_index_varname "${cfg_project_names[${project_i}]}")"
		local project_index_varname_char="$(get_project_index_varname "${cfg_project_chars[${project_i}]}")"

		# Not ideal but seemingly the only way to declare a global variable in a function when the name
		# of that variable is stored in another variable. Otherwise I can simply use name=value syntax
		export ${project_index_varname}="${project_i}"
		export ${project_index_varname_long}="${project_i}"
		export ${project_index_varname_char}="${project_i}"
	done

	# Pull additional config parameters for any git dependant projects
	for project_i in "${cfg_git_dependant_project_indices[@]}"; do
		local tracked_project="$(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS}[${project_i}].${CFG_KEY_TRACKS_PROJECT}")"
		local tracked_project_i="$(get_project_index "${tracked_project}")"
		cfg_tracked_projects+=("${tracked_project_i}")
		cfg_project_tracked_by["${tracked_project_i}"]="${project_i}"
	done

	return 0
}

function create_jq_filter_check_for_array_of_keys() {
	local keys=("$@")
	local jq_filter=''

	for key in "${keys[@]}"; do
		jq_filter+="has(\"${key}\") and "
	done

	jq_filter="${jq_filter% and }"
	printf "${jq_filter}\n"
}

function create_jq_filter_check_for_valid_value() {
	local valid_values=("$@")
	local jq_filter=''

	for val in "${valid_values[@]}"; do
		jq_filter+="index(\"${val}\") or "
	done

	jq_filter="${jq_filter% or }"
	printf "${jq_filter}\n"
}

function validate_config() {
	local config_json_content="$1"
	local validation_failed='false'

	local jq_filter_unique_check="length == (unique | length)"
	local jq_filter_required_key_check="$(create_jq_filter_check_for_array_of_keys "${CFG_PROJECT_REQUIRED_FIELDS[@]}")"
	local jq_filter_required_env_variable_key_check="$( \
		create_jq_filter_check_for_array_of_keys "${CFG_PROJECT_REQUIRED_ENV_VARIABLE_FIELDS[@]}" \
	)"
	local jq_filter_valid_project_type="$(create_jq_filter_check_for_valid_value "${CFG_ALLOWED_PROJECT_TYPES[@]}")"
	local jq_filter_urls_required_key_check="$(create_jq_filter_check_for_array_of_keys "${CFG_REQUIRED_URLS[@]}")"
	local jq_filter_has_urls="has(\"${CFG_KEY_URLS}\")"
	local jq_filter_urls_setup_check="
		(${jq_filter_has_urls} | not) or
		((${jq_filter_has_urls}) and (.${CFG_KEY_URLS} | ${jq_filter_urls_required_key_check}))"
	local jq_filter_django_required_key_check="$(create_jq_filter_check_for_array_of_keys "${CFG_DJANGO_REQUIRED_FIELDS[@]}")"
	local jq_filter_django_env_variable_required_key_check="$(create_jq_filter_check_for_array_of_keys "${CFG_DJANGO_REQUIRED_ENV_VARIABLE_FIELDS[@]}")"
	local jq_filter_project_setup_check="
		if .${CFG_KEY_TYPE} == \"${PROJECT_TYPE_DJANGO}\"
		then ((${jq_filter_django_required_key_check}) and (.${CFG_KEY_ENV_VARIABLES} | ${jq_filter_django_env_variable_required_key_check}))
		else true end"

	# Run validation checks on config and store results
	local -a cfg_project_indices=( $(echo "${config_json_content}" | jq -r ".${CFG_BASE_KEY_PROJECTS} | keys[]") )
	local -a cfg_project_names=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_NAME}") )
	local -a project_names_are_valid=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_NAME} | test(\"${CFG_VALID_NAME_REGEX}\")") )
	local -a project_short_names_are_valid=(
		$(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_SHORT_NAME} | test(\"${CFG_VALID_NAME_REGEX}\")")
	)
	local -a project_chars_are_valid=(
		$(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CLI_CHAR} | test(\"${CFG_VALID_CHAR_REGEX}\")")
	)
	local project_short_names_are_unique="$(echo "${config_json_content}" | jq -r "[${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_SHORT_NAME}] | ${jq_filter_unique_check}")"
	local project_chars_are_unique="$(echo "${config_json_content}" | jq -r "[${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_CLI_CHAR}] | ${jq_filter_unique_check}")"
	local -a projects_have_required_keys=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_required_key_check}") )
	local -a projects_have_required_env_variable_keys=(
		$(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECT_ENV_VARIABLES} | ${jq_filter_required_env_variable_key_check}")
	)
	local -a projects_have_valid_types=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT}.${CFG_KEY_TYPE} | ${jq_filter_valid_project_type}") )
	local -a projects_have_valid_type_setup=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_project_setup_check}") )
	local -a projects_have_valid_url_setup=( $(echo "${config_json_content}" | jq -r "${JQ_FILTER_PROJECTS_IT} | ${jq_filter_urls_setup_check}") )

	# Check for failed validation and inform user of failure
	if [[ "${project_short_names_are_unique}" = 'false' ]]; then
		validation_failed='true'
		print_format "${STYLE_ERROR}" "Project short names in config must be unique"
	fi

	if [[ "${project_chars_are_unique}" = 'false' ]]; then
		validation_failed='true'
		print_format "${STYLE_ERROR}" "Project cli chars in config must be unique"
	fi

	for project_i in ${!cfg_project_indices[@]}; do
		if [[ "${project_names_are_valid[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' has an invalid name: Only characters, digits and _ are allowed"
		fi

		if [[ "${project_short_names_are_valid[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' has an invalid short name: Only characters, digits and _ are allowed"
		fi

		if [[ "${project_chars_are_valid[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' has an invalid cli char: Only characters and digits are allowed"
		fi

		if [[ "${projects_have_required_keys[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' config requires following keys: ${CFG_PROJECT_REQUIRED_FIELDS[*]}"
		fi

		if [[ "${projects_have_required_env_variable_keys[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' config requires following env variables: ${CFG_PROJECT_REQUIRED_ENV_VARIABLE_FIELDS[*]}"
		fi

		if [[ "${projects_have_valid_types[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' is not one of the supported types: ${CFG_ALLOWED_PROJECT_TYPES[*]}"
		fi

		if [[ "${projects_have_valid_type_setup[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' config requires following django keys: ${CFG_DJANGO_REQUIRED_FIELDS[*]}"
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' config requires following django env variables: ${CFG_DJANGO_REQUIRED_ENV_VARIABLE_FIELDS[*]}"
		fi

		if [[ "${projects_have_valid_url_setup[${project_i}]}" = 'false' ]]; then
			validation_failed='true'
			print_format "${STYLE_ERROR}" \
			"Project ${project_i} '${cfg_project_names[${project_i}]}' config requires following urls: ${CFG_REQUIRED_URLS[*]}"
		fi
	done

	if [[ "${validation_failed}" = 'true' ]]; then
		return 1
	fi

	return 0
}


######## MAPPING FUNCTIONS ########

function get_project_index_varname() {
	local project="$1"
	printf "proj_i_${project}"
}

function get_project_index() {
	local project="$1"
	local project_index_varname="$(get_project_index_varname "${project}")"

	if [[ -z "${!project_index_varname}" ]]; then
		return 1
	fi

	printf "${!project_index_varname}"
	return 0
}

function get_project_from_option() {
	local option="$1"

	if [[ "${option}" =~ ${VALID_PROJECT_OPTION_LONG} ]]; then
		project_short_name="${option:2}"
		printf "${project_short_name}"

	elif [[ "${option}" =~ ${VALID_PROJECT_OPTION_CHAR} ]]; then
		project_char="${option:1}"
		printf "${project_char}"

	else
		return 1
	fi

	return 0
}


######## UTILITY FUNCTIONS ########

function is_in_array() {
	local search="$1"
	local arr=("${@:2}")

	for val in "${arr[@]}"; do
		if [[ "${search}" = "${val}" ]]; then
			return 0
		fi
	done

	return 1
}

function is_valid_base_option() {
	local search="$1"
	is_in_array "${search}" "${ALLOWED_OPTIONS_BASE[@]}"
}

function is_valid_command() {
	local search="$1"
	is_in_array "${search}" "${COMMANDS[@]}"
}

function is_valid_project() {
	local search="$1"
	is_in_array "${search}" "${cfg_projects[@]}"
}

function is_valid_project_for_freeze_command() {
	local project="$1"
	local -i project_i
	project_i=$(get_project_index "${project}") || return 1
	[[ "${cfg_project_types[${project_i}]}" = "${PROJECT_TYPE_DJANGO}" ]]
}

function is_valid_project_tag_for_build_command() {
	local search="$1"
	is_in_array "${search}" "${build_command_project_tags[@]}"
}

function is_valid_run_command_option() {
	local search="$1"
	is_in_array "${search}" "${RUN_COMMAND_ALLOWED_OPTIONS[@]}"
}

function is_valid_freeze_command_option() {
	local search="$1"
	is_in_array "${search}" "${FREEZE_COMMAND_ALLOWED_OPTIONS[@]}"
}

function is_valid_restore_command_option() {
	local search="$1"
	is_in_array "${search}" "${RESTORE_COMMAND_ALLOWED_OPTIONS[@]}"
}

function is_valid_build_command_project() {
	local project="$1"
	local -i project_i

	project_i=$(get_project_index "${project}") || return 1

	is_in_array "${project_i}" "${cfg_git_independant_project_indices[@]}" \
	  && is_in_array "${project_i}" "${cfg_project_indices[@]}"
}

function is_valid_build_command_option() {
	local option="$1"
	local project="$(get_project_from_option "${option}")"
	is_valid_build_command_project "${project}"
}

function print_format() {
	local type="$1"
	local msg="$2"

	case "${type}" in
		"${style_command_title}")
			printf "\n%s\n" "${FM_YELLOW}${FM_BOLD}TASK:${FM_RESET} ${FM_BOLD}${msg}${FM_RESET}"
			printf "%s\n" "--------------------------------------------------------------"
			;;
		"${STYLE_ERROR}")
			printf "${FM_RED}ERR!${FM_RESET} ${msg}\n" 1>&2
			;;
	esac

	return 0
}


######## BASE TASK FUNCTIONS ########

function activate_code_env() {
	local code_type="$1"
	local env_name="$2"
	local run_install="$3"
	local title="Loading ${code_type} environment '${env_name}'$([[ "${run_install}" != 'true' ]] ||  printf ' (with package install)')"

	print_format "${style_command_title}" "${title}"

	source "${VENV_ROOT}/${code_type}/${env_name}/bin/activate" || return 1

	if [[ "${run_install}" = 'true'  ]]; then
		case "${code_type}" in
			"${VIRTUAL_ENV_TYPE_PY}")
				pip install -r requirements.txt -U || return 1
				;;
			"${VIRTUAL_ENV_TYPE_NODE}")
				npm install || return 1
				git checkout -- package-lock.json || return 1
				;;
		esac
	fi

	return 0
}

function change_dir() {
	local dir_name="$1"
	print_format "${style_command_title}" "Changing directory to '${dir_name}'"
	cd "${dir_name}"
}

function checkout_git_branch() {
	local branch_name="$1"
	print_format "${style_command_title}" "Checking out branch '${branch_name}'"
	git fetch --all || return 1
	git checkout "${branch_name}" || return 1
	git pull || return 1
	return 0
}

function has_file_changes_between_branches_based_on_pattern() {
	local project="$1"
	local branch_from="$2"
	local branch_to="$3"
	local file_pattern_to_find="$4"

	# Want to compare against the remote branch we're going to in case
	# there is no local copy or an outdated local copy
	local remote_branch_to="origin/${branch_to}"

	local -i project_i=$(get_project_index "${project}")
	local project_dir="${cfg_project_dirs[${project_i}]}"
	local git_output="$(git --no-pager -C "${project_dir}" diff --name-only "${branch_from}..${remote_branch_to}" "${file_pattern_to_find}" )"

	if [[ -z "${git_output}" ]]; then
		printf 'false'
	else
		printf 'true'
	fi

	return 0
}

function run_command() {
	print_format "${style_command_title}" "Running command '$*'"
	$@
}

function create_clean_db() {
	local db_name="$1"
	local clean_db_name="${db_name}_${CLEAN_DB_SUFFIX}"

	print_format "${style_command_title}" "Creating clean copy of database '${db_name}' as '${clean_db_name}'"

	# Create clean copy of database, overwriting it if it already exists
	local base_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '${db_name}'" )"
	local clean_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '${clean_db_name}'" )"

	if [[ "${base_db_exists}" != "1" ]]; then
		print_format "${STYLE_ERROR}" "${MESSAGE_DB_DOES_NOT_EXIST}: '${db_name}'"
		return 1
	fi

	if [[ "${clean_db_exists}" = "1" ]]; then
		psql -c "
			DROP DATABASE \"${clean_db_name}\";
		" || return 1
	fi

	psql -c "
		CREATE DATABASE \"${clean_db_name}\" WITH TEMPLATE \"${db_name}\";
	" || return 1

	return 0
}

function restore_from_clean_db() {
	local db_name="$1"
	local delete_clean_db="$2"
	local clean_db_name="${db_name}_${CLEAN_DB_SUFFIX}"

	print_format "${style_command_title}" "Restoring database '${db_name}' from '${clean_db_name}'"

	local base_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '${db_name}'" )"
	local clean_db_exists="$( psql -tAc "SELECT 1 FROM pg_database WHERE datname = '${clean_db_name}'" )"

	if [[ "${clean_db_exists}" != '1' ]]; then
		print_format "${STYLE_ERROR}" "${MESSAGE_DB_DOES_NOT_EXIST}: '${clean_db_name}'"
		return 1
	fi

	# Stop processes connected to db quickly
	psql -c "
		SELECT pg_terminate_backend(pg_stat_activity.pid)
		FROM pg_stat_activity
		WHERE pg_stat_activity.datname = '${db_name}'
		AND pid <> pg_backend_pid();
	" || return 1

	# Drop altered db
	if [[ "${base_db_exists}" = '1'  ]]; then
		psql -c "
			DROP DATABASE \"${db_name}\";
		" || return 1
	fi

	# Restore clean database to old name
	psql -c "
		CREATE DATABASE \"${db_name}\" WITH TEMPLATE \"${clean_db_name}\";
	" || return 1

	# Drop clean db if flag is set
	if [ "${delete_clean_db}" = 'true' ]; then
		print_format "${style_command_title}" "Deleting clean database '${clean_db_name}' after successful restore"
		psql -c "
			DROP DATABASE \"${clean_db_name}\";
		" || return 1
	fi

	return 0
}

function django_migrate_db() {
	print_format "${style_command_title}" 'Django migrate database'
	python manage.py migrate || return 1
}

function load_termsheet_templates() {
	print_format "${style_command_title}" 'Loading termsheet templates'
	python manage.py load_termsheet_templates --noinput || return 1
}

function django_start_server() {
	local port="$1"
	print_format "${style_command_title}" "Starting django server on port '${port}'"
	python manage.py runserver "${port}"
}

function django_start_celery() {
	local app_name="$1"
	local priority="$2"

	print_format "${style_command_title}" "Starting '${app_name}' celery worker $([[ -z "${priority}" ]] || printf "%s" "(${priority})")"

	if [[ -n "${priority}" ]]; then
		celery -A "${app_name}" worker -Q "${priority}"
	else
		celery -A "${app_name}" worker
	fi
}

function npm_run_watch() {
	print_format "${style_command_title}" 'Starting npm watch'
	npm run watch
}

function goto_project() {
	local project="$1"
	local run_install="$2"
	local branch="$3"

	local -i project_i=$(get_project_index "${project}")
	local project_dir="${cfg_project_dirs[${project_i}]}"
	local project_virtual_env_type="${cfg_project_virtual_env_types[${project_i}]}"
	local project_virtual_env_name="${cfg_project_virtual_env_names[${project_i}]}"

	change_dir "${project_dir}" || return 1

	if [[ -n "${branch}" ]]; then
		checkout_git_branch "${branch}" || return 1
	fi

	activate_code_env "${project_virtual_env_type}" "${project_virtual_env_name}" "${run_install}" || return 1

	return 0
}

function setup_project_branch() {
	local project="$1"
	local run_install="$2"
	local branch="$3"

	local -i project_i=$(get_project_index "${project}")
	local project_type="${cfg_project_types[${project_i}]}"

	goto_project "${project}" "${run_install}" "${branch}" || return 1

	if [[ "${project_type}" = "${PROJECT_TYPE_DJANGO}" ]]; then
		# These arguments are only required for django projects
		local run_migrations="$4"
		local load_ts_templates="$5"
		local project_requires_load_ts_templates="${cfg_project_requires_load_termsheet_templates[${project_i}]}"

		if [[ "${run_migrations}" = 'true' ]]; then
			django_migrate_db || return 1
		fi

		if [[ "${project_requires_load_ts_templates}" = 'true' && "${load_ts_templates}" = 'true'  ]]; then
			load_termsheet_templates || return 1
		fi
	fi

	return 0
}

function run_django_start_server() {
	local project="$1"
	local port="$2"
	goto_project "${project}" 'false' || return 1
	django_start_server "${port}"
}

function run_django_start_celery() {
	local project="$1"
	local app_name="$2"
	local priority="$3"
	goto_project "${project}" 'false' || return 1
	django_start_celery "${app_name}" "${priority}"
}

function run_npm_run_watch() {
	local project="$1"
	goto_project "${project}" 'false' || return 1
	npm_run_watch
}


######## TMUX SESSION MANAGEMENT ########

function get_tmux_session_name_regex() {
	local session_name_regex="^${SCRIPT_NAME}"

	# Dynamically builds regex pattern based on projects in config
	for proj_i in "${cfg_git_independant_project_indices[@]}"; do
		local project_short_name="${cfg_project_short_names[${proj_i}]}"
		session_name_regex+="(${SESH_NAME_SEP}(${project_short_name})=([0-9A-z_/.-]+))?"
	done

	session_name_regex+='$'

	printf "${session_name_regex}"
}

function run_command_with_tmux_unlock() {
	local tmux_lock_channel="$1"
	shift
	$@ && tmux wait-for -S "${tmux_lock_channel}"
}

function get_running_tmux_session_with_regex() {
	local session_name_regex="$1"
	local tmux_sessions=( $(tmux list-sessions -F "#{session_name}") )
	local matched_session_running='false'
	local -i num_of_matched_sessions=0

	for sesh in "${tmux_sessions[@]}"; do
		if [[ "${sesh}" =~ ${session_name_regex} ]]; then
			local matched_session_running='true'
			local num_of_matched_sessions=$((++num_of_matched_sessions))
			if [[ ${num_of_matched_sessions} -gt 1 ]]; then
				print_format "${STYLE_ERROR}" "${MESSAGE_MULTIPLE_RUNNING_TMUX_SESSIONS}. Session #${num_of_matched_sessions}: ${sesh}"
			fi
		fi
	done

	if [[ "${matched_session_running}" = 'true' && ${num_of_matched_sessions} -eq 1 ]]; then
		for match in "${BASH_REMATCH[@]}"; do
			printf "%s\n" "${match}"
		done
		return 0
	elif [[ "${matched_session_running}" = 'true' ]]; then
		return 2
	else
		return 1
	fi
}

function create_tmux_worker_window() {
	local tmux_session_name="$1"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	if ! is_in_array "${TMUX_WINDOW_NAME_WORKER}" "${tmux_windows[@]}"; then
		tmux new-window -dk -t "${tmux_session_name}:0" -n "${TMUX_WINDOW_NAME_WORKER}" || return 1
	fi

	return 0
}

function delete_tmux_worker_window() {
	local tmux_session_name="$1"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	if is_in_array "${TMUX_WINDOW_NAME_WORKER}" "${tmux_windows[@]}"; then
		tmux kill-window -t "${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}" || return 1
	fi

	return 0
}

function update_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="$3"

	local -i project_i=$(get_project_index "${project}")
	local project_dir="${cfg_project_dirs[${project_i}]}"
	local project_type="${cfg_project_types[${project_i}]}"
	local tmux_windows=( $(tmux list-windows -t "${tmux_session_name}" -F "#{window_name}") )

	if [[ "${update_type}" = "${TMUX_UPDATE_TYPE_SET_ENV_VAR}" && ( -z "$4" || -z "$5" ) ]]; then
		print_format "${STYLE_ERROR}" "Environment variables cannot be added as they are not set"
		return 1
	else
		local env_var_key="$4"
		local env_var_value="$5"
	fi

	case "${project_type}" in
		"${PROJECT_TYPE_DJANGO}")
			local win_name_django="${project}${TMUX_WIN_NAME_DJANGO_SUFFIX}"
			local win_name_celery="${project}${TMUX_WIN_NAME_CELERY_SUFFIX}"
			local project_celery_app_name="${cfg_project_celery_app_names[${project_i}]}"

			case "${update_type}" in
				"${TMUX_UPDATE_TYPE_CREATE}")
					# Creates the windows necessary for the project
					if ! is_in_array "${win_name_django}" "${tmux_windows[@]}"; then
						tmux new-window -da -c "${project_dir}" -t "${tmux_session_name}:{end}" -n "${win_name_django}" || return 1
						tmux send-keys -t "${tmux_session_name}:${win_name_django}" \
							 "tmux wait-for -S ${TMUX_DEFAULT_LOCK_CHANNEL}" 'C-m' || return 1
						tmux wait-for "${TMUX_DEFAULT_LOCK_CHANNEL}" || return 1
					fi

					if [[ "${project_celery_app_name}" != 'null' ]]; then
						if ! is_in_array "${win_name_celery}" "${tmux_windows[@]}"; then
							tmux new-window -da -c "${project_dir}" -t "${tmux_session_name}:{end}" -n "${win_name_celery}" || return 1
							tmux split-window -c "${project_dir}" -t "${tmux_session_name}:${win_name_celery}" || return 1
							tmux send-keys -t "${tmux_session_name}:${win_name_celery}.1" \
								 "tmux wait-for -S ${TMUX_DEFAULT_LOCK_CHANNEL}" 'C-m' || return 1
							tmux wait-for "${TMUX_DEFAULT_LOCK_CHANNEL}" || return 1
						fi
					fi
					;;

				"${TMUX_UPDATE_TYPE_DELETE}")
					# Deletes the windows for the project
					if is_in_array "${win_name_django}" "${tmux_windows[@]}"; then
						tmux kill-window -t "${tmux_session_name}:${win_name_django}" || return 1
					fi

					if [[ "${project_celery_app_name}" != 'null' ]]; then
						if is_in_array "${win_name_celery}" "${tmux_windows[@]}"; then
							tmux kill-window -t "${tmux_session_name}:${win_name_celery}" || return 1
						fi
					fi
					;;

				"${TMUX_UPDATE_TYPE_KILL_SIG}")
					# Sends a kill signal to all active windows - useful before setting environment variables
					tmux send-keys -t "${tmux_session_name}:${win_name_django}" 'C-c' || return 1
					if [[ "${project_celery_app_name}" != 'null' ]]; then
						tmux send-keys -t "${tmux_session_name}:${win_name_celery}.0" 'C-c' || return 1
						tmux send-keys -t "${tmux_session_name}:${win_name_celery}.1" 'C-c' || return 1
					fi
					;;

				"${TMUX_UPDATE_TYPE_SET_ENV_VAR}")
					# Sets environment variables in the windows of a project
					tmux send-keys -t "${tmux_session_name}:${win_name_django}" "export ${env_var_key}=${env_var_value}" 'C-m' || return 1

					if [[ "${project_celery_app_name}" != 'null' ]]; then
						tmux send-keys -t "${tmux_session_name}:${win_name_celery}.0" \
							"export ${env_var_key}=${env_var_value}" 'C-m' || return 1

						tmux send-keys -t "${tmux_session_name}:${win_name_celery}.1" \
							"export ${env_var_key}=${env_var_value}" 'C-m' || return 1
					fi

					# Always send environment variables to the worker to ensure it can run scripts properly
					tmux send-keys -t "${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}" \
						"export ${env_var_key}=${env_var_value} && tmux wait-for -S ${TMUX_DEFAULT_LOCK_CHANNEL}" 'C-m' || return 1
					tmux wait-for "${TMUX_DEFAULT_LOCK_CHANNEL}" || return 1
					;;
			esac
			;;

		"${PROJECT_TYPE_NODE}")
			local win_name_npm_watch="${project}${TMUX_WIN_NAME_NPM_WATCH_SUFFIX}"

			case "${update_type}" in
				"${TMUX_UPDATE_TYPE_CREATE}")
					# Creates the windows necessary for the project
					if ! is_in_array "${win_name_npm_watch}" "${tmux_windows[@]}"; then
						tmux new-window -da -c "${project_dir}" -t "${tmux_session_name}:{end}" -n "${win_name_npm_watch}" || return 1
						tmux send-keys -t "${tmux_session_name}:${win_name_npm_watch}" \
							 "tmux wait-for -S ${TMUX_DEFAULT_LOCK_CHANNEL}" 'C-m' || return 1
						tmux wait-for "${TMUX_DEFAULT_LOCK_CHANNEL}" || return 1
					fi
					;;

				"${TMUX_UPDATE_TYPE_DELETE}")
					# Deletes the windows for the project
					if is_in_array "${win_name_npm_watch}" "${tmux_windows[@]}"; then
						tmux kill-window -t "${tmux_session_name}:${win_name_npm_watch}" || return 1
					fi
					;;

				"${TMUX_UPDATE_TYPE_KILL_SIG}")
					# Sends a kill signal to all active windows - useful before setting environment variables
					tmux send-keys -t "${tmux_session_name}:${win_name_npm_watch}" 'C-c' || return 1
					;;

				"${TMUX_UPDATE_TYPE_SET_ENV_VAR}")
					# Sets environment variables in the windows of a project
					tmux send-keys -t "${tmux_session_name}:${win_name_npm_watch}" "export ${env_var_key}=${env_var_value}" 'C-m' || return 1

					# Always send environment variables to the worker to ensure it can run scripts properly
					tmux send-keys -t "${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}" \
						"export ${env_var_key}=${env_var_value} && tmux wait-for -S ${TMUX_DEFAULT_LOCK_CHANNEL}" 'C-m' || return 1
					tmux wait-for "${TMUX_DEFAULT_LOCK_CHANNEL}" || return 1
					;;
			esac
			;;
	esac

	return 0
}

function create_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="${TMUX_UPDATE_TYPE_CREATE}"
	update_tmux_windows_for_project "${tmux_session_name}" "${project}" "${update_type}"
}

function delete_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="${TMUX_UPDATE_TYPE_DELETE}"
	update_tmux_windows_for_project "${tmux_session_name}" "${project}" "${update_type}"
}

function stop_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local update_type="${TMUX_UPDATE_TYPE_KILL_SIG}"
	update_tmux_windows_for_project "${tmux_session_name}" "${project}" "${update_type}"
}

function load_env_var_in_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local env_var_key="$3"
	local env_var_value="$4"
	local update_type="${TMUX_UPDATE_TYPE_SET_ENV_VAR}"
	update_tmux_windows_for_project "${tmux_session_name}" "${project}" "${update_type}" "${env_var_key}" "${env_var_value}"
}

function refresh_tmux_windows_for_project() {
	local tmux_session_name="$1"
	local project="$2"
	local branch_from="$3"
	local branch_to="$4"
	local force_reload="$5"

	local -i project_i=$(get_project_index "${project}")
	local project_dir="${cfg_project_dirs[${project_i}]}"
	local project_type="${cfg_project_types[${project_i}]}"

	case "${project_type}" in
		"${PROJECT_TYPE_DJANGO}")
			# If there is a currently running session, check what the most effecient way to update is.
			# Otherwise update everything
			if [[ -n "${branch_from}" ]]; then
				local run_install="$(has_file_changes_between_branches_based_on_pattern "${project}" "${branch_from}" \
					"${branch_to}" "${FILE_PATTERN_PY_REQUIRMENTS}" )"
				local run_migrations="$(has_file_changes_between_branches_based_on_pattern "${project}" "${branch_from}" \
					"${branch_to}" "${FILE_PATTERN_DJANGO_MIGRATIONS}" )"
				local load_ts_templates="$(has_file_changes_between_branches_based_on_pattern "${project}" "${branch_from}" \
					"${branch_to}" "${FILE_PATTERN_TS_TEMPLATES}" )"
			else
				local run_install='true'
				local run_migrations='true'
				local load_ts_templates='true'
			fi

			local win_name_django="${project}${TMUX_WIN_NAME_DJANGO_SUFFIX}"
			local win_name_celery="${project}${TMUX_WIN_NAME_CELERY_SUFFIX}"
			local project_celery_app_name="${cfg_project_celery_app_names[${project_i}]}"
			local project_port="${cfg_project_ports[${project_i}]}"

			printf "${project} run_install = ${run_install}\n"
			printf "${project} run_migrations = ${run_migrations}\n"
			printf "${project} load_ts_templates = ${load_ts_templates}\n"

			if [[ "${project_celery_app_name}" != 'null' && -n "${branch_from}" ]]; then
				# Celery needs to be restarted for any change in code, database or packages
				tmux send-keys -t "${tmux_session_name}:${win_name_celery}.0" "C-c" "C-l" || return 1
				tmux send-keys -t "${tmux_session_name}:${win_name_celery}.1" "C-c" "C-l" || return 1
			fi

			if [[ ( "${run_install}" = 'true' || "${force_reload}" = 'true' ) && -n "${branch_from}" ]]; then
				# The django server only needs restarting for changes in packages
				tmux send-keys -t "${tmux_session_name}:${win_name_django}" "C-c" "C-l" || return 1
			fi

			# Setups the new branch in the most effecient way possible, blocking further execution till it succeeds
			tmux send-keys -t "${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}" \
				"${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} run_command_with_tmux_unlock ${TMUX_DEFAULT_LOCK_CHANNEL} " \
				"setup_project_branch ${project} ${run_install} ${branch_to} ${run_migrations} ${load_ts_templates}" "C-m" || return 1
			tmux wait-for "${TMUX_DEFAULT_LOCK_CHANNEL}"

			if [[ "${project_celery_app_name}" != 'null' ]]; then
				# Start up celery once branch is loaded
				tmux send-keys -t "${tmux_session_name}:${win_name_celery}.0" \
					"${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} run_django_start_celery ${project} ${project_celery_app_name} high_priority" "C-m" || return 1
				tmux send-keys -t "${tmux_session_name}:${win_name_celery}.1" \
					"${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} run_django_start_celery ${project} ${project_celery_app_name}" "C-m" || return 1
			fi

			if [[ "${run_install}" = 'true' || "${force_reload}" = 'true' ]]; then
				# Start up django server if new packages were installed or if window was just opened
				tmux send-keys -t "${tmux_session_name}:${win_name_django}" \
					"${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} run_django_start_server ${project} ${project_port}" "C-m" || return 1
			fi
			;;

		"${PROJECT_TYPE_NODE}")
			# If there is a currently running session, check what the most effecient way to update is.
			# Otherwise update everything
			if [[ -n "${branch_from}" ]]; then
				local run_install="$(has_file_changes_between_branches_based_on_pattern "${project}" "${branch_from}" \
					"${branch_to}" "${FILE_PATTERN_NODE_REQUIREMENTS}" )"
			else
				local run_install='true'
			fi

			local win_name_npm_watch="${project}${TMUX_WIN_NAME_NPM_WATCH_SUFFIX}"

			printf "${project} run_install = ${run_install}\n"

			if [[ "${run_install}" = 'true' || "${force_reload}" = 'true' ]]; then
				# If node requirements have changed, npm watch needs to be restarted
				if [[ -n "${branch_from}" ]]; then
					tmux send-keys -t "${tmux_session_name}:${win_name_npm_watch}" "C-c" "C-l" || return 1
				fi

				# Setups the new branch in the most effecient way possible, blocking further execution till it succeeds
				tmux send-keys -t "${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}" \
					"${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} run_command_with_tmux_unlock ${TMUX_DEFAULT_LOCK_CHANNEL} " \
					"setup_project_branch ${project} ${run_install} ${branch_to}" "C-m" || return 1
				tmux wait-for "${TMUX_DEFAULT_LOCK_CHANNEL}" || return 1
				tmux send-keys -t "${tmux_session_name}:${win_name_npm_watch}" \
					"${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} run_npm_run_watch ${project}" "C-m" || return 1
			else
				# No need to restart the npm watch if there are no changes in the node requirements
				tmux send-keys -t "${tmux_session_name}:${TMUX_WINDOW_NAME_WORKER}" \
					"${SCRIPT_NAME} ${COMMAND_SCIPT_RUN} setup_project_branch ${project} ${run_install} ${branch_to}" "C-m" || return 1
			fi
			;;
	esac

	return 0
}


######## COMMAND-SPECIFIC FUNCTIONS ########

function handle_base_options() {
	local option="$1"
	local next_arg="$2"

	case "${option}" in
		"${OPTION_HELP}" | "${OPTION_HELP_SHORT}")
			printf "${MESSAGE_USAGE_HELP}\n"
			;;
		"${OPTION_VERBOSE}" | "${OPTION_VERBOSE_SHORT}")
			printf "${MESSAGE_VERBOSE}\n"
			verbose_mode='true'
			if [[ -z "${next_arg}" ]]; then
				print_format "${STYLE_ERROR}" "${MESSAGE_NOT_ENOUGH_ARGS}\n"
				printf "${MESSAGE_USAGE_HELP}\n"
				return 1
			fi
			;;
		"${OPTION_VERSION}")
			printf "${VERSION}\n"
			;;
	esac

	return 0
}

function build() {
	local -a project_branches_from
	local -a project_branches_to
	local -a env_vars_to_set

	if [[ $# -eq 0 ]]; then
		print_format "${STYLE_ERROR}" "${MESSAGE_NOT_ENOUGH_ARGS}"
		return 1

	else
		for (( i=1; i<=$#; i+=2 )); do
			local option="${!i}"

			if is_valid_build_command_option "${option}"; then
				local branch_index=$((i + 1))
				local branch="${!branch_index}"
				local project
				local -i project_i

				project="$(get_project_from_option "${option}")" || return 1
				project_i=$(get_project_index "${project}") || return 1

				if [[ $# -lt ${branch_index} ]]; then
					print_format "${STYLE_ERROR}" "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
					return 1

				else
					project_branches_to[${project_i}]="${branch}"

					# This is for projects in the same git repository as another project and therefore track its branch
					if is_in_array "${project_i}" "${cfg_tracked_projects[@]}"; then
						local tracking_project_i="${cfg_project_tracked_by[${project_i}]}"
						project_branches_to[${tracking_project_i}]="${project_branches_to[${project_i}]}"
					fi
				fi

			else
				print_format "${STYLE_ERROR}" "${MESSAGE_UNKNOWN_ARG}: ${option}"
				printf "${MESSAGE_USAGE}\n"
				return 1
			fi

		done
	fi

	# Starts tmux server only if it is not already running
	tmux start-server || return 1

	local -a tmux_session_rematch
	local tmux_session_name_regex="$(get_tmux_session_name_regex)"
	tmux_session_rematch=( $(get_running_tmux_session_with_regex "${tmux_session_name_regex}") )
	local -i tmux_session_rematch_ret=$?
	local tmux_sesh_name_new="${SCRIPT_NAME}"

	for proj_i in "${cfg_git_independant_project_indices[@]}"; do
		local branch_to="${project_branches_to[${proj_i}]}"

		if [[ -n "${branch_to}" ]]; then
			local project_short_name="${cfg_project_short_names[${proj_i}]}"
			tmux_sesh_name_new+="${SESH_NAME_SEP}${project_short_name}=${branch_to}"
		fi
	done

	if [[ ${tmux_session_rematch_ret} -ge 2 ]]; then
		# Multiple tmux sessions were found, exiting with error
		return 1

	elif [[ ${tmux_session_rematch_ret} -eq 1 ]]; then
		# No tmux session was found - creating new environment
		tmux new-session -d -s "${tmux_sesh_name_new}" -n "${TMUX_WINDOW_NAME_DEFAULT}"

	else
		# Tmux session found, pulling old branch names and updating project windows
		local tmux_sesh_name_old="${tmux_session_rematch[0]}"

		for (( i=0; i<${#tmux_session_rematch[@]}; i++ )); do
			local match="${tmux_session_rematch[$i]}"
			local -i after_match_index=$((i + 1))

			if is_valid_build_command_project "${match}"; then
				local project="${match}"
				local -i project_i=$(get_project_index "${project}")
				project_branches_from[${project_i}]="${tmux_session_rematch[${after_match_index}]}"

				# This is for projects in the same git repository as another project and therefore track its branch
				if is_in_array "${project_i}" "${cfg_tracked_projects[@]}"; then
					local tracking_project_i="${cfg_project_tracked_by[${project_i}]}"
					project_branches_from[${tracking_project_i}]="${project_branches_from[${project_i}]}"
				fi
			fi
		done

		tmux rename-session -t "${tmux_sesh_name_old}" "${tmux_sesh_name_new}" || return 1
	fi

	create_tmux_worker_window "${tmux_sesh_name_new}" || return 1

	# Load independent projects first and capture env variables needed for dependent projects
	for proj_i in "${cfg_independant_project_indices[@]}"; do
		printf "\n"
		printf "proj_i = ${proj_i}\n"

		local branch_from="${project_branches_from[${proj_i}]}"
		local branch_to="${project_branches_to[${proj_i}]}"
		local proj_short_name="${cfg_project_short_names[${proj_i}]}"

		printf "proj_short_name = ${proj_short_name}\n"
		printf "branch_from = ${branch_from}\n"
		printf "branch_to = ${branch_to}\n"

		# TODO: Add functionality for other default branch names to get to kod-dev, om-qa and om-master urls
		if [[ -n "${branch_to}" ]]; then
			create_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" || return 1
			refresh_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" "${branch_from}" "${branch_to}" 'false' || return 1

			if is_in_array "${proj_i}" "${cfg_projects_with_url_env_var_indices[@]}"; then
				local env_var_url="${cfg_project_url_local[${proj_i}]}"
				env_vars_to_set["${proj_i}"]="${env_var_url}"
			fi

		else
			delete_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" || return 1

			if is_in_array "${proj_i}" "${cfg_projects_with_url_env_var_indices[@]}"; then
				local env_var_url="${cfg_project_url_default[${proj_i}]}"
				env_vars_to_set["${proj_i}"]="${env_var_url}"
			fi
		fi
	done

	printf "\n"
	for proj_i in "${!env_vars_to_set[@]}"; do
		local evn="${cfg_project_url_env_var_names[${proj_i}]}"
		local evv="${env_vars_to_set[${proj_i}]}"
		printf "%s\n" "${evn} = ${evv}"
	done

	# Load dependent projects and add env variables from the independent projects
	for proj_i in "${cfg_dependant_project_indices[@]}"; do
		printf "\n"
		printf "proj_i = ${proj_i}\n"

		local branch_from="${project_branches_from[${proj_i}]}"
		local branch_to="${project_branches_to[${proj_i}]}"
		local proj_short_name="${cfg_project_short_names[${proj_i}]}"

		printf "proj_short_name = ${proj_short_name}\n"
		printf "branch_from = ${branch_from}\n"
		printf "branch_to = ${branch_to}\n"

		if [[ -n "${branch_to}" ]]; then
			create_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" || return 1

			# Stop tmux window process and add the necessary environment variables to them
			stop_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" || return 1

			for env_var_proj_i in "${!env_vars_to_set[@]}"; do
				local env_var_key="${cfg_project_url_env_var_names[${env_var_proj_i}]}"
				local env_var_value="${env_vars_to_set[${env_var_proj_i}]}"
				printf "Setting env variable ${env_var_key}=${env_var_value}\n"
				load_env_var_in_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" \
					"${env_var_key}" "${env_var_value}" || return 1
			done

			refresh_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" "${branch_from}" "${branch_to}" 'true' || return 1

		else
			delete_tmux_windows_for_project "${tmux_sesh_name_new}" "${proj_short_name}" || return 1
		fi
	done

	delete_tmux_worker_window "${tmux_sesh_name_new}" || return 1

	return 0
}

function freeze() {
	local project="$1"
	local -i project_i=$(get_project_index "${project}")

	if [[ $# -eq 0 ]]; then
		print_format "${STYLE_ERROR}" "${MESSAGE_NOT_ENOUGH_ARGS}"
		return 1
	fi

	if [[ $# -ge 2 ]]; then
		if is_valid_freeze_command_option "$2"; then
			local option="$2"

			case "${option}" in
				"${OPTION_BRANCH}"|"${OPTION_BRANCH_SHORT}")
					if [[ $# -ne 3 ]]; then
						print_format "${STYLE_ERROR}" "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
						return 1
					else
						local branch="$3"
					fi
					;;
			esac
		else
			print_format "${STYLE_ERROR}" "${MESSAGE_UNKNOWN_ARG}: $2"
			printf "${MESSAGE_USAGE}\n"
			return 1
		fi
	else
		local branch="${FREEZE_COMMAND_DEFAULT_BRANCH}"
	fi

	if is_valid_project_for_freeze_command "${project}"; then
		local project_db_name="${cfg_project_db_names[${project_i}]}"
		setup_project_branch "${project}" 'true' "${branch}" 'true' 'true' || return 1
		create_clean_db "${project_db_name}" || return 1

	elif is_valid_project "${project}"; then
		print_format "${STYLE_ERROR}" "${MESSAGE_COMMAND_DOES_NOT_SUPPORT_PROJECT}: '${project}'"
		return 1

	else
		print_format "${STYLE_ERROR}" "${MESSAGE_UNKNOWN_PROJECT}: '${project}'"
		return 1
	fi

	return 0
}

function restore() {
	local project="$1"

	local -i project_i=$(get_project_index "${project}")
	local delete_db='false'

	if [[ $# -eq 0 ]]; then
		print_format "${STYLE_ERROR}" "${MESSAGE_NOT_ENOUGH_ARGS}"
		return 1
	fi

	if [[ $# -ge 2 ]]; then
		if is_valid_restore_command_option "$2"; then
			local option="$2"

			case "${option}" in
				"${OPTION_DELETE}"|"${OPTION_DELETE_SHORT}")
					local delete_db='true'
					;;
			esac
		else
			print_format "${STYLE_ERROR}" "${MESSAGE_UNKNOWN_ARG}: $2"
			printf "${MESSAGE_USAGE}\n"
			return 1
		fi
	fi

	if is_valid_project_for_freeze_command "${project}"; then
		local project_db_name="${cfg_project_db_names[${project_i}]}"
		restore_from_clean_db "${project_db_name}" "${delete_db}" || return 1

	elif is_valid_project "${project}"; then
		print_format "${STYLE_ERROR}" "${MESSAGE_COMMAND_DOES_NOT_SUPPORT_PROJECT}: '${project}'"
		return 1

	else
		print_format "${STYLE_ERROR}" "${MESSAGE_UNKNOWN_PROJECT}: '${project}'"
		return 1
	fi

	return 0
}

function run() {
	local project="$1"

	if [[ $# -lt 2 ]]; then
		print_format "${STYLE_ERROR}" "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
		return 1
	fi

	if is_valid_run_command_option "$2"; then
		local option="$2"

		case "${option}" in
			"${OPTION_BRANCH}"|"${OPTION_BRANCH_SHORT}")
				if [[ $# -lt 4 ]]; then
					print_format "${STYLE_ERROR}" "${MESSAGE_INCORRECT_NUM_OF_ARGS}"
					return 1
				else
					local branch="$3"
					shift 3
				fi
				;;
		esac
	else
		shift
	fi

	if is_valid_project "${project}"; then
		goto_project "${project}" 'false' "${branch}" || return 1
		run_command "$@" || return 1
	else
		print_format "${STYLE_ERROR}" "${MESSAGE_UNKNOWN_PROJECT}: '${project}'"
		return 1
	fi

	return 0
}

function check() {
	local set_verbose="$1"
	local verbose='false'
	local vars_missing='false'
	local command_on_path='true'

	if [[ "${verbose_mode}" = 'true' || "${set_verbose}" = 'true' ]]; then
		local verbose='true'
		print_format "${style_command_title}" "${MESSAGE_CHECK}"
	fi

	for ev in "${cfg_env_vars_required[@]}"; do
		if [[ -z "${!ev+x}" ]]; then
			local vars_missing='true'
			printf "Checking '${ev}' is set... ${FM_RED}UNSET${FM_RESET}\n"
		else
			if [[ "${verbose}" = 'true' ]]; then
				printf "Checking '${ev}' is set... ${FM_GREEN}OK${FM_RESET}\n"
			fi
		fi
	done

	# Checks if the script is on the PATH
	if command -v "${SCRIPT_NAME}" &>/dev/null; then
		if [[ "${verbose}" = 'true' ]]; then
			printf "Checking '${SCRIPT_NAME}' is on PATH... ${FM_GREEN}OK${FM_RESET}\n"
		fi
	else
		command_on_path='false'
		printf "Checking '${SCRIPT_NAME}' is on PATH... ${FM_RED}NOT FOUND${FM_RESET}\n"
	fi

	if [[ "${vars_missing}" = 'true' || "${command_on_path}" = 'false' ]]; then
		printf "\n${FM_RED}CHECK FAILED${FM_RESET}\n"
		printf "Please resolve issues in ${FM_RED}RED${FM_RESET} before running the program\n"
		return 1
	elif [[ "${verbose}" = 'true' ]]; then
		printf "\n${FM_GREEN}CHECK PASSED${FM_RESET}\n"
	fi

	return 0
}

function print_config() {
	jq '.' "${CONFIG_FILEPATH}"
}

function reset() {
	local tmux_sessions=( $(tmux list-sessions -F "#{session_name}") )
	local tmux_session_name_regex="$(get_tmux_session_name_regex)"

	for session in "${tmux_sessions[@]}"; do
		if [[ "${session}" =~ ${tmux_session_name_regex} ]]; then
			tmux kill-session -t "${session}"
		fi
	done

	tmux wait-for -S "${TMUX_DEFAULT_LOCK_CHANNEL}"
}

function script_run() {
	$@ || print_format "${STYLE_ERROR}" "${MESSAGE_FUNCTION_RETURNED_ERROR}"
	return 0
}

function handle_command() {
	local command="$1"

	load_config || return 1

	shift

	case "${command}" in
		"${COMMAND_BUILD}")
			check && build "$@" || return 1
			;;
		"${COMMAND_FREEZE}")
			check && freeze "$@" || return 1
			;;
		"${COMMAND_RESTORE}")
			check && restore "$@" || return 1
			;;
		"${COMMAND_RUN}")
			check && run "$@" || return 1
			;;
		"${COMMAND_CHECK}")
			check 'true' || return 1
			;;
		"${COMMAND_PRINT_CONFIG}")
			check && print_config || return 1
			;;
		"${COMMAND_RESET}")
			check && reset || return 1
			;;
		"${COMMAND_SCIPT_RUN}")
			check && script_run "$@" || return 1
			;;
	esac

	return 0
}


######## MAIN SCRIPT ########

function main() {
	if [[ $# -eq 0 ]]; then
		# Not enough arguments passed
		printf "${MESSAGE_NOT_ENOUGH_ARGS}\n\n"
		printf "${MESSAGE_USAGE_HELP}\n"
		return 1

	else
		for arg in "$@"; do
			if is_valid_base_option "${arg}"; then
				handle_base_options "$@" || return 1
				shift

			elif is_valid_command "${arg}"; then
				time handle_command "$@" || return 1
				return 0

			else
				printf "${MESSAGE_UNKNOWN_ARG}: ${arg}\n"
				printf "${MESSAGE_USAGE}\n"
				return 1
			fi
		done
	fi
}

main "$@" || exit 1

